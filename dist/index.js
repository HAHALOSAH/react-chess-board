'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');

var Staunty = {
    bB: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m25 5.767c-2.1056 0-3.8124 0.87865-3.8121 1.9632l1.5166 2.6505c-16.049 14.089-5.707 27.135-5.707 27.135h16.006s7.0496-8.6714 0.76227-19.51l-2.989 4.8276c-0.67072 1.0833-1.9632 1.4898-2.898 0.91107-0.93477-0.57872-1.1472-1.917-0.47652-3.0003l3.8867-6.2771c-1.1073-1.3449-2.4252-2.7101-3.9926-4.0861l1.5166-2.6505c0-1.0846-1.7066-1.9632-3.8121-1.9632z", style: { fill: "#5f5955", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m25 5.767c-0.8164 0-1.5711 0.1335-2.1913 0.35847 4.3387 0.84718 4.9765 1.1195 2.5601 4.3506l3.246 3.5665c-3.6565 8.2403-1.6037 7.9919-1.6037 7.9919s0.6964-2.6485 4.1117-7.7689c-1.0722-1.2796-2.3377-2.578-3.8266-3.8851l1.5161-2.6501c1e-4 -1.0845-1.7067-1.9631-3.8123-1.9634zm8.7655 12.238-1.0091 1.5127c3.7363 8.4129-4.1347 17.997-4.1347 17.997h4.3815c0.1581 0.0339 6.958-8.8438 0.76227-19.51z", style: { fill: "#000000", opacity: .18 } }), jsxRuntime.jsx("path", { d: "m15.145 31.721c-0.2191-0.0314-3.4233-9.7859 5.7543-18.751-2.3019 1.895-7.1351 13.163-5.7543 18.751z", style: { fill: "#ffffff", opacity: .25 } }), jsxRuntime.jsx("path", { d: "m23.292 10.196-1.4772-2.5943s0.2425-0.72175 1.7808-1.0472c-1.7266 1.3502-0.988 1.6622-0.3036 3.6415z", style: { fill: "#ffffff", opacity: .25 } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.2349-2.6723-0.1726-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2607-0.3313 0.5021-0.6131 0.8866-0.8491 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5317 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bK: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink" }, { children: [jsxRuntime.jsx("path", { d: "m27.67 15.225v-3.5436h4.4396v-4.4293h-4.9344v-3.8933h-4.366v3.8933h-4.9344v4.4293h4.4396v3.5436", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("rect", { x: "20.299", y: "14.215", width: "9.3984", height: "2.7873", ry: "1.3937", style: { fill: "#5f5955", paintOrder: "normal", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m26.416 14.215c0.72479 0 1.3082 0.62142 1.3082 1.3935 0 0.77209-0.58336 1.3935-1.3082 1.3935h1.9736c0.72478 0 1.3081-0.62144 1.3081-1.3935 0-0.77209-0.58336-1.3935-1.3081-1.3935z", style: { fill: "#000000", opacity: .18, paintOrder: "normal" } }), jsxRuntime.jsx("path", { d: "m21.631 14.842c-0.40169 0-0.72499 0.34468-0.72499 0.77259 0 0.42787 0.3233 0.77227 0.72499 0.77227h0.87379c-0.40169 0-0.72499-0.3444-0.72499-0.77227 0-0.42791 0.3233-0.77259 0.72499-0.77259z", style: { fill: "#ffffff", opacity: .25, paintOrder: "normal" } }), jsxRuntime.jsx("path", { d: "m33.635 36.986s7.776-13.318 6.6127-15.916c-1.1632-2.5964-8.4802-4.4974-15.248-4.4974-6.7677 0-14.084 1.9004-15.248 4.4974-1.1632 2.5966 6.6127 15.916 6.6127 15.916z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m24.996 16.576c15.938 2.6216 12.573 9.3539 6.6406 22.543l2.0273-1.7288s7.7472-13.723 6.5839-16.32c-1.5452-2.8334-7.5027-4.1592-15.252-4.4945z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m23.765 17.295c-3.904-0.18436-14.621 1.8014-13.503 5.0167 0.81724 3.7274 2.7544 7.244 4.5085 10.504-5.6872-10.335-5.9421-13.774 8.9943-15.521z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m23.391 3.997-0.01613 3.3123h0.54565l0.01622-3.3123zm-4.9311 3.8699-0.0075 3.2077h0.77316l0.0075-3.2077zm4.4128 3.213 0.02573 2.4859h0.52l-0.02573-2.4859z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m26.189 3.3582-1.9e-5 3.8935h0.98678l2.8e-5 -3.8935zm4.441 3.8937v4.9453h1.4802v-4.9453zm-4.4396 4.4291 2.7e-5 2.4923h1.4802l-2.8e-5 -2.4923z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#000000", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.0481-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.23495-2.6723-0.17255-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22904-0.69925 0.83943-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88663-0.84901 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.0479 11.692 1.6191c0.39104 0.24 0.59243 0.53161 0.85561 0.87009 0.0258-0.0759-0.40837-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bN: (jsxRuntime.jsx("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: jsxRuntime.jsxs("g", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", shapeRendering: "geometricPrecision" }, { children: [jsxRuntime.jsx("path", { d: "m25.192 23.015c-0.16544 6.9672-11.758 5.2189-11.516 18.104l22.86 0.1184c-2.094-6.442 9.69-25.16-11.931-32.258v-1e-4s-2.4381-2.601-5.9655-2.8237l0.2227 3.5347-4.5583 4.5816c-2.6294 3.1455-8.7347 8.3784-7.7513 9.6111 3.1158 5.3041 6.3306 4.4316 6.3306 4.4316 4.2418-4.5433 5.8193-2.0894 12.309-5.2997z", fill: "#5f5955", imageRendering: "auto", stroke: "#1e1e1e", strokeLinejoin: "round", strokeWidth: "1.2" }), jsxRuntime.jsx("path", { d: "m19.32 14.694c-0.7757 0.86088-0.6902 1.1156-0.8137 2.1503 0.8055 0.12316 1.5069 0.23982 2.2486 0.0656 2.3809-1.262 0.075-3.4026-1.4347-2.2162z", imageRendering: "auto", opacity: ".4", style: { paintOrder: "fill markers stroke" } }), jsxRuntime.jsx("path", { d: "m9.1916 22.166c-0.8496 0.4078-0.9984 0.9608-1.0565 1.4754 0.7288 0.4181 1.8765-0.1255 2.0412-1.4316l-0.9846-0.044z", imageRendering: "auto", opacity: ".35" }), jsxRuntime.jsx("path", { d: "m8.1905 25.15s0.6525 1.1374-1.1019-1.641c0.6594-1.9774 8.263-9.0796 12.438-13.534l-0.1836-3.0857s1.0689 1.6901 1.2475 3.468c-4.3898 4.39-12.22 10.833-12.824 13.213 0.023 0.6738 0.24 1.0278 0.4231 1.5797z", fill: "#fff", imageRendering: "auto", opacity: ".25" }), jsxRuntime.jsx("path", { d: "m13.26 28.257c2.0291-3.3367 8.3914-3.2239 11.932-5.2424 0.3228 0.1024 0.1304 1.3697 0.2398 1.23 0.8476-1.0903 2.9259-3.279 0.8684-6.8743 0.5214 5.9575-13.718 5.5912-15.89 10.305-0.2005 0.4355 2.1818 0.7932 2.85 0.5818z", imageRendering: "auto", opacity: ".18" }), jsxRuntime.jsx("path", { d: "m25.8 23.781c-1.0131 5.8132-9.5449 6.1169-10.988 12.641 2.8332-6.4058 10.762-5.7136 10.988-12.641z", fill: "#fff", imageRendering: "auto", opacity: ".25" }), jsxRuntime.jsx("path", { d: "m18.64 6.1556s3.051 0.73807 4.9045 3.9825c20.499 7.1536 7.6413 27.937 5.7883 31.073l7.2034 0.026c-1.9871-3.2431 9.5482-25.597-11.931-32.258-1.7757-1.0691-2.7677-2.6092-5.9655-2.8238z", imageRendering: "auto", opacity: ".18" }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.235-2.6723-0.1725-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", fill: "#5f5955", imageRendering: "auto", stroke: "#1e1e1e", strokeLinejoin: "round", strokeWidth: "1.2" }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1373-11.624 1.6658c-0.3698 0.2291-0.6992 0.8394-0.9536 1.3902 0.2608-0.3313 0.5022-0.613 0.8867-0.849 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5316 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", fill: "#fff", imageRendering: "auto", opacity: ".25" })] })) }))),
    bP: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m21.503 27.594h6.9944m-9.4974-10.086c0 1.7315 0.7123 3.3873 1.9657 4.587l-3.6504 2.0999 0.43091 3.3988h4.3059c-0.79438 3.559-2.7548 7.3308-5.0622 8.6173s-5.2994 3.0968-4.8425 8.189l25.706 2.1e-5c0.45687-5.0922-2.5352-6.9025-4.8425-8.189-2.3074-1.2865-4.2678-5.0583-5.0622-8.6173h4.3059l0.43091-3.3988-3.6503-2.0999c1.2533-1.1996 1.9655-2.8554 1.9655-4.5869 3.11e-4 -3.3667-2.628-5.9118-6.0006-5.9118-3.3726-1.1e-5 -6.0008 2.545-6.0006 5.9117z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m24.962 11.537c1.1709-0.4586 9.5273 5.9057 0.64714 10.773l4.512 2.1-0.56221 3.125h2.6586l0.42868-3.3987-3.6504-2.0999c1.2534-1.1996 1.9618-2.5812 1.9646-4.3128-0.46888-5.4159-5.9985-6.1861-5.9985-6.1861zm-2.9485 15.998c4.5025 7.9337 9.4701 9.994 13.074 9.9646l-2.1157-1.347c-2.075-1.4895-4.7317-4.8572-5.0622-8.6177z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision", strokeWidth: .26457 } }), jsxRuntime.jsx("path", { d: "m21.983 22.213-1.647 2.3466-2.3561-0.01371 4.013-2.3234z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.307 12.267c-2.5425 0.1381-5.73 3.1733-4.3848 6.9183l0.19878 0.64312c-0.3298-3.4894 2.1268-7.1169 4.186-7.5614z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m17.863 37.625c-3.9839 2.3053-5.117 6.1402-5.117 6.1402-0.01037 0-0.54754-4.1751 3.9564-6.654 4.5039-2.4789 4.8215-6.1507 5.8602-8.8927-0.63708 3.7031-0.71573 7.1012-4.6996 9.4065z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } })] }))),
    bQ: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m24.959 5.0937a2.9585 3.3158 90 0 0-3.3155 2.9585 2.9585 3.3158 90 0 0 3.3155 2.9585 2.9585 3.3158 90 0 0 3.316-2.9585 2.9585 3.3158 90 0 0-3.316-2.9585z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", paintOrder: "normal", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m24.836 5.7323c-0.37582-0.20962-3.7243 0.80586-2.1848 3.5753-0.23547-1.5446 0.43755-3.2031 2.1848-3.5753z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.959 11.011c-6.5068 0-9.5953 5.8843-9.5951 10.358h19.263c1.99e-4 -4.4741-3.1607-10.358-9.6676-10.358z", style: { fill: "#5f5955", paintOrder: "normal", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m18.161 14.977c1.0418-1.4783 2.9196-3.2199 6.8404-3.3796-0.31072 0.27709-4.7888 1.1374-6.8404 3.3796z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.836 5.0067s0.04572 0.23808-1e-4 0c2.4799 1.1289 2.0497 3.8473 0.81734 5.547 7.3536 3.8036 2.2125 8.669 2.2122 8.6681h2.7008c1.7619 1.287 7.2086-2.7409-3.8351-8.669 3.5276-3.1154 0.09642-5.6072-1.8952-5.5466z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 15.225c-1.971 0-2.3483 2.6494-4.1366 2.8592-1.8213 0.21366-3.3816-2.3114-5.2505-1.7361-1.4945 0.46001-0.77828 2.5999-1.8053 3.1752-1.4018 0.78508-3.1845-1.8324-5.2902-0.29827 6.8387 8.8288 8.0859 12.377 7.9833 18.819l16.998-9.9e-5c-0.10268-6.4426 1.1445-9.9904 7.9831-18.819-2.1056-1.5341-3.8884 1.0833-5.2901 0.29827-1.0271-0.57526-0.31082-2.7152-1.8053-3.1752-1.8688-0.57526-3.4293 1.9498-5.2506 1.7361-1.7884-0.20981-2.1655-2.8592-4.1365-2.8592z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m9.8952 19.34c-0.13588-0.0099-0.33139 0.05615-0.45862 0.08471 3.0815 4.0999 6.5751 9.5372 7.0991 12.417-1.4062-4.9323-3.2664-9.5622-6.1403-12.472z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m39.974 18.735c-9.4852 10.003-9.9239 17.985-16.941 19.31h10.476c-0.10268-6.4427 1.1445-9.9905 7.9831-18.819 0 0-0.68803-0.75582-1.5179-0.49124z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m14.912 18.945c0.20277-0.08767 1.1841-1.8078 1.9805-1.9501-1.42-0.34555-1.6188-0.0463-1.9805 1.9501z", style: { fill: "#ffffff", opacity: 25 } }), jsxRuntime.jsx("path", { d: "m22.511 17.876c0.95342-0.84704 1.6333-2.6551 3.2379-1.8453-0.79746-0.22882-2.2148 1.0403-3.2379 1.8453z", style: { fill: "#ffffff", opacity: 25 } }), jsxRuntime.jsx("path", { d: "m31.12 18.133c0.20983 0.06994 2.1762-1.6423 2.8625-1.2176 0 0-1.4313 1.1196-2.8625 1.2176z", style: { fill: "#ffffff", opacity: 25 } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237l27.182-1e-4c0.2349-2.6723-0.1726-5.2635-1.8999-6.3237-2.5598-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2608-0.3313 0.5021-0.613 0.8866-0.849 2.5597-1.5711 11.691-1.6192 11.691-1.6192s9.1318 0.048 11.692 1.6192c0.3911 0.24 0.5925 0.5316 0.8556 0.87 0.026-0.076-0.4083-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bR: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m17.932 20.414c4.9056-0.74066 9.5787-0.57845 14.136 0m-17.885-10.752c-1.0592 8.7669 1.1034 10.677 3.7482 10.752l-3.3154 18.159h20.767l-3.3154-18.159c2.6448-0.0745 4.8074-1.9849 3.7482-10.752l-3.6072-0.52917-1.0733 3.6427-3.1416-0.0995-0.5222-3.754h-4.9448l-0.52127 3.754-3.142 0.0995-1.0733-3.6427z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m17.932 20.414c6.828 0 13.118 0.40763 14.948 16.572l2.3187 0.38585-3.1311-16.428c-0.03144-0.30772-6.0881-1.8224-14.136-0.52917z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m14.777 10.219 2.2766-0.28599c-1.9137 0.31197-2.3128 5.2958-2.3128 5.2958-0.23801-0.17655-0.18808-4.9033 0.03618-5.0098z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25.276 9.5507c-1.6477 0-2.5191 2.7475-2.5191 2.7475l0.33726-2.7288z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m32.671 9.8162 0.93397 0.11826c-0.78478 0.49954-1.5905 1.9884-1.5905 1.9884z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m18.472 20.964 2.6206-0.29312c-2.6206 0.29312-4.8959 13.053-4.9066 13.113z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m34.013 9.3979c0.35682 6.3635-1.9499 10.603-8.0415 10.536l4.778 0.56323c7.5226 0.30904 5.101-10.806 5.0671-10.835z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.04814-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237h27.182c0.23496-2.6723-0.17255-5.2635-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsxRuntime.jsx("path", { d: "m25 37.146s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22905-0.69926 0.83944-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88664-0.84902 2.5597-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.04794 11.692 1.6191c0.39104 0.24 0.59242 0.53161 0.85561 0.87009 0.02583-0.0759-0.40837-1.1579-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    wB: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m25 5.767c-2.1056 0-3.8124 0.87865-3.8121 1.9632l1.5166 2.6505c-16.049 14.089-5.707 27.135-5.707 27.135h16.006s7.0496-8.6714 0.76227-19.51l-2.989 4.8276c-0.67072 1.0833-1.9632 1.4898-2.898 0.91107-0.93477-0.57872-1.1472-1.917-0.47652-3.0003l3.8867-6.2771c-1.1073-1.3449-2.4252-2.7101-3.9926-4.0861l1.5166-2.6505c0-1.0846-1.7066-1.9632-3.8121-1.9632z", style: { fill: "#f0f0f0", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m25 5.767c-0.8164 0-1.5711 0.1335-2.1913 0.35847 4.3387 0.84718 4.9765 1.1195 2.5601 4.3506l3.246 3.5665c-3.6565 8.2403-1.6037 7.9919-1.6037 7.9919s0.6964-2.6485 4.1117-7.7689c-1.0722-1.2796-2.3377-2.578-3.8266-3.8851l1.5161-2.6501c1e-4 -1.0845-1.7067-1.9631-3.8123-1.9634zm8.7655 12.238-1.0091 1.5127c3.7363 8.4129-4.1347 17.997-4.1347 17.997h4.3815c0.1581 0.0339 6.958-8.8438 0.76227-19.51z", style: { fill: "#000000", opacity: .15 } }), jsxRuntime.jsx("path", { d: "m15.145 31.721c-0.2191-0.0314-3.4233-9.7859 5.7543-18.751-2.3019 1.895-7.1351 13.163-5.7543 18.751z", style: { fill: "#ffffff" } }), jsxRuntime.jsx("path", { d: "m23.292 10.196-1.4772-2.5943s0.2425-0.72175 1.7808-1.0472c-1.7266 1.3502-0.988 1.6622-0.3036 3.6415z", style: { fill: "#ffffff" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.2349-2.6723-0.1726-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2607-0.3313 0.5021-0.6131 0.8866-0.8491 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5317 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wK: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink" }, { children: [jsxRuntime.jsx("path", { d: "m27.67 15.225v-3.5436h4.4396v-4.4293h-4.9344v-3.8933h-4.366v3.8933h-4.9344v4.4293h4.4396v3.5436", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("rect", { x: "20.299", y: "14.215", width: "9.3984", height: "2.7873", ry: "1.3937", style: { fill: "#f0f0f0", paintOrder: "normal", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m26.416 14.215c0.72479 0 1.3082 0.62142 1.3082 1.3935 0 0.77209-0.58336 1.3935-1.3082 1.3935h1.9736c0.72478 0 1.3081-0.62144 1.3081-1.3935 0-0.77209-0.58336-1.3935-1.3081-1.3935z", style: { fill: "#000000", opacity: .15, paintOrder: "normal" } }), jsxRuntime.jsx("path", { d: "m21.631 14.842c-0.40169 0-0.72499 0.34468-0.72499 0.77259 0 0.42787 0.3233 0.77227 0.72499 0.77227h0.87379c-0.40169 0-0.72499-0.3444-0.72499-0.77227 0-0.42791 0.3233-0.77259 0.72499-0.77259z", style: { fill: "#ffffff", paintOrder: "normal" } }), jsxRuntime.jsx("path", { d: "m33.635 36.986s7.776-13.318 6.6127-15.916c-1.1632-2.5964-8.4802-4.4974-15.248-4.4974-6.7677 0-14.084 1.9004-15.248 4.4974-1.1632 2.5966 6.6127 15.916 6.6127 15.916z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m24.996 16.576c15.938 2.6216 12.573 9.3539 6.6406 22.543l2.0273-1.7288s7.7472-13.723 6.5839-16.32c-1.5452-2.8334-7.5027-4.1592-15.252-4.4945z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m23.765 17.295c-3.904-0.18436-14.621 1.8014-13.503 5.0167 0.81724 3.7274 2.7544 7.244 4.5085 10.504-5.6872-10.335-5.9421-13.774 8.9943-15.521z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m23.391 3.997-0.01613 3.3123h0.54565l0.01622-3.3123zm-4.9311 3.8699-0.0075 3.2077h0.77316l0.0075-3.2077zm4.4128 3.213 0.02573 2.4859h0.52l-0.02573-2.4859z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m26.189 3.3582-1.9e-5 3.8935h0.98678l2.8e-5 -3.8935zm4.441 3.8937v4.9453h1.4802v-4.9453zm-4.4396 4.4291 2.7e-5 2.4923h1.4802l-2.8e-5 -2.4923z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#000000", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.0481-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.23495-2.6723-0.17255-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22904-0.69925 0.83943-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88663-0.84901 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.0479 11.692 1.6191c0.39104 0.24 0.59243 0.53161 0.85561 0.87009 0.0258-0.0759-0.40837-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wN: (jsxRuntime.jsx("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: jsxRuntime.jsxs("g", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", shapeRendering: "geometricPrecision" }, { children: [jsxRuntime.jsx("path", { d: "m25.192 23.015c-0.16544 6.9672-11.758 5.2189-11.516 18.104l22.86 0.1184c-2.094-6.442 9.69-25.16-11.931-32.258v-1e-4s-2.4381-2.601-5.9655-2.8237l0.2227 3.5347-4.5583 4.5816c-2.6294 3.1455-8.7347 8.3784-7.7513 9.6111 3.1158 5.3041 6.3306 4.4316 6.3306 4.4316 4.2418-4.5433 5.8193-2.0894 12.309-5.2997z", fill: "#f0f0f0", imageRendering: "auto", stroke: "#3c3c3c", strokeLinejoin: "round", strokeWidth: "1.2" }), jsxRuntime.jsx("path", { d: "m19.32 14.694c-0.7757 0.86088-0.6902 1.1156-0.8137 2.1503 0.8055 0.12316 1.5069 0.23982 2.2486 0.0656 2.3809-1.262 0.075-3.4026-1.4347-2.2162z", imageRendering: "auto", opacity: ".35", style: { paintOrder: "fill markers stroke" } }), jsxRuntime.jsx("path", { d: "m9.1916 22.166c-0.8496 0.4078-0.9984 0.9608-1.0565 1.4754 0.7288 0.4181 1.8765-0.1255 2.0412-1.4316l-0.9846-0.044z", imageRendering: "auto", opacity: ".3" }), jsxRuntime.jsx("path", { d: "m8.1905 25.15s0.6525 1.1374-1.1019-1.641c0.6594-1.9774 8.263-9.0796 12.438-13.534l-0.1836-3.0857s1.0689 1.6901 1.2475 3.468c-4.3898 4.39-12.22 10.833-12.824 13.213 0.023 0.6738 0.24 1.0278 0.4231 1.5797z", fill: "#fff", imageRendering: "auto" }), jsxRuntime.jsx("path", { d: "m13.26 28.257c2.0291-3.3367 8.3914-3.2239 11.932-5.2424 0.3228 0.1024 0.1304 1.3697 0.2398 1.23 0.8476-1.0903 2.9259-3.279 0.8684-6.8743 0.5214 5.9575-13.718 5.5912-15.89 10.305-0.2005 0.4355 2.1818 0.7932 2.85 0.5818z", imageRendering: "auto", opacity: ".15" }), jsxRuntime.jsx("path", { d: "m25.8 23.781c-1.0131 5.8132-9.5449 6.1169-10.988 12.641 2.8332-6.4058 10.762-5.7136 10.988-12.641z", fill: "#fff", imageRendering: "auto" }), jsxRuntime.jsx("path", { d: "m18.64 6.1556s3.051 0.73807 4.9045 3.9825c20.499 7.1536 7.6413 27.937 5.7883 31.073l7.2034 0.026c-1.9871-3.2431 9.5482-25.597-11.931-32.258-1.7757-1.0691-2.7677-2.6092-5.9655-2.8238z", imageRendering: "auto", opacity: ".15" }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.235-2.6723-0.1725-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", fill: "#f0f0f0", imageRendering: "auto", stroke: "#3c3c3c", strokeLinejoin: "round", strokeWidth: "1.2" }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1373-11.624 1.6658c-0.3698 0.2291-0.6992 0.8394-0.9536 1.3902 0.2608-0.3313 0.5022-0.613 0.8867-0.849 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5316 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", fill: "#fff", imageRendering: "auto" })] })) }))),
    wP: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m21.503 27.594h6.9944m-9.4974-10.086c0 1.7315 0.7123 3.3873 1.9657 4.587l-3.6504 2.0999 0.43091 3.3988h4.3059c-0.79438 3.559-2.7548 7.3308-5.0622 8.6173s-5.2994 3.0968-4.8425 8.189l25.706 2.1e-5c0.45687-5.0922-2.5352-6.9025-4.8425-8.189-2.3074-1.2865-4.2678-5.0583-5.0622-8.6173h4.3059l0.43091-3.3988-3.6503-2.0999c1.2533-1.1996 1.9655-2.8554 1.9655-4.5869 3.11e-4 -3.3667-2.628-5.9118-6.0006-5.9118-3.3726-1.1e-5 -6.0008 2.545-6.0006 5.9117z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m24.962 11.537c1.1709-0.4586 9.5273 5.9057 0.64714 10.773l4.512 2.1-0.56221 3.125h2.6586l0.42868-3.3987-3.6504-2.0999c1.2534-1.1996 1.9618-2.5812 1.9646-4.3128-0.46888-5.4159-5.9985-6.1861-5.9985-6.1861zm-2.9485 15.998c4.5025 7.9337 9.4701 9.994 13.074 9.9646l-2.1157-1.347c-2.075-1.4895-4.7317-4.8572-5.0622-8.6177z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision", strokeWidth: .26457 } }), jsxRuntime.jsx("path", { d: "m21.983 22.213-1.647 2.3466-2.3561-0.01371 4.013-2.3234z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.307 12.267c-2.5425 0.1381-5.73 3.1733-4.3848 6.9183l0.19878 0.64312c-0.3298-3.4894 2.1268-7.1169 4.186-7.5614z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m17.863 37.625c-3.9839 2.3053-5.117 6.1402-5.117 6.1402-0.01037 0-0.54754-4.1751 3.9564-6.654 4.5039-2.4789 4.8215-6.1507 5.8602-8.8927-0.63708 3.7031-0.71573 7.1012-4.6996 9.4065z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wQ: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m24.959 5.0937a2.9585 3.3158 90 0 0-3.3155 2.9585 2.9585 3.3158 90 0 0 3.3155 2.9585 2.9585 3.3158 90 0 0 3.316-2.9585 2.9585 3.3158 90 0 0-3.316-2.9585z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", paintOrder: "normal", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m24.836 5.7323c-0.37582-0.20962-3.7243 0.80586-2.1848 3.5753-0.23547-1.5446 0.43755-3.2031 2.1848-3.5753z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.959 11.011c-6.5068 0-9.5953 5.8843-9.5951 10.358h19.263c1.99e-4 -4.4741-3.1607-10.358-9.6676-10.358z", style: { fill: "#f0f0f0", paintOrder: "normal", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m18.161 14.977c1.0418-1.4783 2.9196-3.2199 6.8404-3.3796-0.31072 0.27709-4.7888 1.1374-6.8404 3.3796z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m24.836 5.0067s0.04572 0.23808-1e-4 0c2.4799 1.1289 2.0497 3.8473 0.81734 5.547 7.3536 3.8036 2.2125 8.669 2.2122 8.6681h2.7008c1.7619 1.287 7.2086-2.7409-3.8351-8.669 3.5276-3.1154 0.09642-5.6072-1.8952-5.5466z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 15.225c-1.971 0-2.3483 2.6494-4.1366 2.8592-1.8213 0.21366-3.3816-2.3114-5.2505-1.7361-1.4945 0.46001-0.77828 2.5999-1.8053 3.1752-1.4018 0.78508-3.1845-1.8324-5.2902-0.29827 6.8387 8.8288 8.0859 12.377 7.9833 18.819l16.998-9.9e-5c-0.10268-6.4426 1.1445-9.9904 7.9831-18.819-2.1056-1.5341-3.8884 1.0833-5.2901 0.29827-1.0271-0.57526-0.31082-2.7152-1.8053-3.1752-1.8688-0.57526-3.4293 1.9498-5.2506 1.7361-1.7884-0.20981-2.1655-2.8592-4.1365-2.8592z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m9.8952 19.34c-0.13588-0.0099-0.33139 0.05615-0.45862 0.08471 3.0815 4.0999 6.5751 9.5372 7.0991 12.417-1.4062-4.9323-3.2664-9.5622-6.1403-12.472z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m39.974 18.735c-9.4852 10.003-9.9239 17.985-16.941 19.31h10.476c-0.10268-6.4427 1.1445-9.9905 7.9831-18.819 0 0-0.68803-0.75582-1.5179-0.49124z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m14.912 18.945c0.20277-0.08767 1.1841-1.8078 1.9805-1.9501-1.42-0.34555-1.6188-0.0463-1.9805 1.9501z", style: { fill: "#ffffff" } }), jsxRuntime.jsx("path", { d: "m22.511 17.876c0.95342-0.84704 1.6333-2.6551 3.2379-1.8453-0.79746-0.22882-2.2148 1.0403-3.2379 1.8453z", style: { fill: "#ffffff" } }), jsxRuntime.jsx("path", { d: "m31.12 18.133c0.20983 0.06994 2.1762-1.6423 2.8625-1.2176 0 0-1.4313 1.1196-2.8625 1.2176z", style: { fill: "#ffffff" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237l27.182-1e-4c0.2349-2.6723-0.1726-5.2635-1.8999-6.3237-2.5598-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2608-0.3313 0.5021-0.613 0.8866-0.849 2.5597-1.5711 11.691-1.6192 11.691-1.6192s9.1318 0.048 11.692 1.6192c0.3911 0.24 0.5925 0.5316 0.8556 0.87 0.026-0.076-0.4083-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wR: (jsxRuntime.jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "m17.932 20.414c4.9056-0.74066 9.5787-0.57845 14.136 0m-17.885-10.752c-1.0592 8.7669 1.1034 10.677 3.7482 10.752l-3.3154 18.159h20.767l-3.3154-18.159c2.6448-0.0745 4.8074-1.9849 3.7482-10.752l-3.6072-0.52917-1.0733 3.6427-3.1416-0.0995-0.5222-3.754h-4.9448l-0.52127 3.754-3.142 0.0995-1.0733-3.6427z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m17.932 20.414c6.828 0 13.118 0.40763 14.948 16.572l2.3187 0.38585-3.1311-16.428c-0.03144-0.30772-6.0881-1.8224-14.136-0.52917z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m14.777 10.219 2.2766-0.28599c-1.9137 0.31197-2.3128 5.2958-2.3128 5.2958-0.23801-0.17655-0.18808-4.9033 0.03618-5.0098z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25.276 9.5507c-1.6477 0-2.5191 2.7475-2.5191 2.7475l0.33726-2.7288z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m32.671 9.8162 0.93397 0.11826c-0.78478 0.49954-1.5905 1.9884-1.5905 1.9884z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m18.472 20.964 2.6206-0.29312c-2.6206 0.29312-4.8888 13.113-4.8888 13.113z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m34.013 9.3979c0.35682 6.3635-1.9499 10.603-8.0415 10.536l4.778 0.56323c7.5226 0.30904 5.101-10.806 5.0671-10.835z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsxRuntime.jsx("path", { d: "m25 36.457s-9.1309 0.04814-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237h27.182c0.23496-2.6723-0.17255-5.2635-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsxRuntime.jsx("path", { d: "m25 37.146s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22905-0.69926 0.83944-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88664-0.84902 2.5597-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.04794 11.692 1.6191c0.39104 0.24 0.59242 0.53161 0.85561 0.87009 0.02583-0.0759-0.40837-1.1579-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] })))
};

class ChessPieceIcon extends React.Component {
    render() {
        return (jsxRuntime.jsx("div", Object.assign({ style: {
                display: typeof this.props.piece == 'object' ? 'block' : 'none',
                position: "relative"
            } }, { children: jsxRuntime.jsx("div", Object.assign({ style: {
                    filter: 'drop-shadow(0 0 0.5rem #aaaaaa)',
                    position: 'absolute',
                    margin: 'auto',
                    inset: '0',
                } }, { children: typeof this.props.piece == 'object' &&
                    [[
                            Staunty['wP'],
                            Staunty['wN'],
                            Staunty['wB'],
                            Staunty['wR'],
                            Staunty['wQ'],
                            Staunty['wK']
                        ], [
                            Staunty['bP'],
                            Staunty['bN'],
                            Staunty['bB'],
                            Staunty['bR'],
                            Staunty['bQ'],
                            Staunty['bK']
                        ]][this.props.piece.color][this.props.piece.type] })) })));
    }
}

class ChessBoardSquare extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        return (jsxRuntime.jsxs("div", Object.assign({ style: {
                backgroundColor: (this.props.square.row + this.props.square.file) % 2 === 0 ? 'white' : '#AAAAAA',
                width: '100%',
                height: '100%',
                cursor: 'pointer',
                position: 'relative'
            }, onMouseDown: this.props.onMouseDown }, { children: [jsxRuntime.jsx("div", { style: {
                        position: 'absolute',
                        inset: '0px',
                        backgroundColor: '#FF8888AA',
                        pointerEvents: 'none',
                        display: this.props.selected ? 'block' : 'none'
                    } }), jsxRuntime.jsx(ChessPieceIcon, { piece: this.props.piece })] })));
    }
}

class ChessBoardSquares extends React.Component {
    constructor(props) {
        super(props);
        this.state = {};
    }
    render() {
        return (jsxRuntime.jsx("div", Object.assign({ style: {
                display: 'grid',
                gridTemplateColumns: 'repeat(8, 1fr)',
                gridTemplateRows: 'repeat(8, 1fr)',
                width: '100%',
                height: '100%',
                alignItems: 'stretch',
            } }, { children: Array(8 * 8).fill(0).map((_, i) => {
                var _a;
                let row = (i / 8) | 0;
                let file = i % 8;
                return (jsxRuntime.jsx(ChessBoardSquare, { piece: this.props.pieces[row][file], square: { row: row, file: file }, selected: ((_a = this.state.selectedSquare) === null || _a === void 0 ? void 0 : _a.row) == row && this.state.selectedSquare.file == file, onMouseDown: () => {
                        this.onSquareClick({ row: row, file: file });
                    } }, i));
            }) })));
    }
    clearSelectedSquare() {
        this.setState({
            selectedSquare: undefined
        });
    }
    setSelectedSquare(square) {
        this.setState({
            selectedSquare: square
        });
    }
    onSquareClick(square) {
        var _a;
        if (((_a = this.state.selectedSquare) === null || _a === void 0 ? void 0 : _a.row) == square.row && this.state.selectedSquare.file == square.file) {
            this.setSelectedSquare();
            return;
        }
        this.setSelectedSquare(square);
    }
}

var ChessColor;
(function (ChessColor) {
    ChessColor[ChessColor["WHITE"] = 0] = "WHITE";
    ChessColor[ChessColor["BLACK"] = 1] = "BLACK";
})(ChessColor || (ChessColor = {}));
var ChessPieceType;
(function (ChessPieceType) {
    ChessPieceType[ChessPieceType["PAWN"] = 0] = "PAWN";
    ChessPieceType[ChessPieceType["KNIGHT"] = 1] = "KNIGHT";
    ChessPieceType[ChessPieceType["BISHOP"] = 2] = "BISHOP";
    ChessPieceType[ChessPieceType["ROOK"] = 3] = "ROOK";
    ChessPieceType[ChessPieceType["QUEEN"] = 4] = "QUEEN";
    ChessPieceType[ChessPieceType["KING"] = 5] = "KING";
})(ChessPieceType || (ChessPieceType = {}));

/**
 * @license
 * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
const WHITE = 'w';
const BLACK = 'b';
const PAWN = 'p';
const KNIGHT = 'n';
const BISHOP = 'b';
const ROOK = 'r';
const QUEEN = 'q';
const KING = 'k';
const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
const EMPTY = -1;
const FLAGS = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q',
};
const BITS = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64,
};
/*
 * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM
 * ----------------------------------------------------------------------------
 * From https://github.com/jhlywa/chess.js/issues/230
 *
 * A lot of people are confused when they first see the internal representation
 * of chess.js. It uses the 0x88 Move Generation Algorithm which internally
 * stores the board as an 8x16 array. This is purely for efficiency but has a
 * couple of interesting benefits:
 *
 * 1. 0x88 offers a very inexpensive "off the board" check. Bitwise AND (&) any
 *    square with 0x88, if the result is non-zero then the square is off the
 *    board. For example, assuming a knight square A8 (0 in 0x88 notation),
 *    there are 8 possible directions in which the knight can move. These
 *    directions are relative to the 8x16 board and are stored in the
 *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two
 *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88
 *    (because of two-complement representation of -18). The non-zero result
 *    means the square is off the board and the move is illegal. Take the
 *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero
 *    means the square is on the board.
 *
 * 2. The relative distance (or difference) between two squares on a 8x16 board
 *    is unique and can be used to inexpensively determine if a piece on a
 *    square can attack any other arbitrary square. For example, let's see if a
 *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is
 *    -80. We add 119 to make the ATTACKS array index non-negative (because the
 *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a
 *    bitmask of pieces that can attack from that distance and direction.
 *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the
 *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn
 *    example, we would check to see if 24 & 0x1 is non-zero, which it is
 *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a
 *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that
 *    there are no blocking pieces between E7 and E2. That's where the RAYS
 *    array comes in. It provides an offset (in this case 16) to add to E7 (20)
 *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.
 */
// prettier-ignore
// eslint-disable-next-line
const Ox88 = {
    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,
    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,
    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,
    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,
    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,
    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,
    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,
    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
};
const PAWN_OFFSETS = {
    b: [16, 32, 17, 15],
    w: [-16, -32, -17, -15],
};
const PIECE_OFFSETS = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14],
    b: [-17, -15, 17, 15],
    r: [-16, 1, 16, -1],
    q: [-17, -16, -15, 1, 17, 16, 15, -1],
    k: [-17, -16, -15, 1, 17, 16, 15, -1],
};
// prettier-ignore
const ATTACKS = [
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,
    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,
    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20
];
// prettier-ignore
const RAYS = [
    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,
    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,
    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,
    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,
    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,
    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,
    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,
    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,
    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,
    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17
];
const PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };
const SYMBOLS = 'pnbrqkPNBRQK';
const PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];
const RANK_1 = 7;
const RANK_2 = 6;
/*
 * const RANK_3 = 5
 * const RANK_4 = 4
 * const RANK_5 = 3
 * const RANK_6 = 2
 */
const RANK_7 = 1;
const RANK_8 = 0;
const ROOKS = {
    w: [
        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },
    ],
    b: [
        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },
    ],
};
const SECOND_RANK = { b: RANK_7, w: RANK_2 };
const TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];
// Extracts the zero-based rank of an 0x88 square.
function rank(square) {
    return square >> 4;
}
// Extracts the zero-based file of an 0x88 square.
function file(square) {
    return square & 0xf;
}
function isDigit(c) {
    return '0123456789'.indexOf(c) !== -1;
}
// Converts a 0x88 square to algebraic notation.
function algebraic(square) {
    const f = file(square);
    const r = rank(square);
    return ('abcdefgh'.substring(f, f + 1) +
        '87654321'.substring(r, r + 1));
}
function swapColor(color) {
    return color === WHITE ? BLACK : WHITE;
}
function validateFen(fen) {
    // 1st criterion: 6 space-seperated fields?
    const tokens = fen.split(/\s+/);
    if (tokens.length !== 6) {
        return {
            ok: false,
            error: 'Invalid FEN: must contain six space-delimited fields',
        };
    }
    // 2nd criterion: move number field is a integer value > 0?
    const moveNumber = parseInt(tokens[5], 10);
    if (isNaN(moveNumber) || moveNumber <= 0) {
        return {
            ok: false,
            error: 'Invalid FEN: move number must be a positive integer',
        };
    }
    // 3rd criterion: half move counter is an integer >= 0?
    const halfMoves = parseInt(tokens[4], 10);
    if (isNaN(halfMoves) || halfMoves < 0) {
        return {
            ok: false,
            error: 'Invalid FEN: half move counter number must be a non-negative integer',
        };
    }
    // 4th criterion: 4th field is a valid e.p.-string?
    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };
    }
    // 5th criterion: 3th field is a valid castle-string?
    if (/[^kKqQ-]/.test(tokens[2])) {
        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };
    }
    // 6th criterion: 2nd field is "w" (white) or "b" (black)?
    if (!/^(w|b)$/.test(tokens[1])) {
        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };
    }
    // 7th criterion: 1st field contains 8 rows?
    const rows = tokens[0].split('/');
    if (rows.length !== 8) {
        return {
            ok: false,
            error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows",
        };
    }
    // 8th criterion: every row is valid?
    for (let i = 0; i < rows.length; i++) {
        // check for right sum of fields AND not two numbers in succession
        let sumFields = 0;
        let previousWasNumber = false;
        for (let k = 0; k < rows[i].length; k++) {
            if (isDigit(rows[i][k])) {
                if (previousWasNumber) {
                    return {
                        ok: false,
                        error: 'Invalid FEN: piece data is invalid (consecutive number)',
                    };
                }
                sumFields += parseInt(rows[i][k], 10);
                previousWasNumber = true;
            }
            else {
                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
                    return {
                        ok: false,
                        error: 'Invalid FEN: piece data is invalid (invalid piece)',
                    };
                }
                sumFields += 1;
                previousWasNumber = false;
            }
        }
        if (sumFields !== 8) {
            return {
                ok: false,
                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',
            };
        }
    }
    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||
        (tokens[3][1] == '6' && tokens[1] == 'b')) {
        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };
    }
    const kings = [
        { color: 'white', regex: /K/g },
        { color: 'black', regex: /k/g },
    ];
    for (const { color, regex } of kings) {
        if (!regex.test(tokens[0])) {
            return { ok: false, error: `Invalid FEN: missing ${color} king` };
        }
        if ((tokens[0].match(regex) || []).length > 1) {
            return { ok: false, error: `Invalid FEN: too many ${color} kings` };
        }
    }
    return { ok: true };
}
// this function is used to uniquely identify ambiguous moves
function getDisambiguator(move, moves) {
    const from = move.from;
    const to = move.to;
    const piece = move.piece;
    let ambiguities = 0;
    let sameRank = 0;
    let sameFile = 0;
    for (let i = 0, len = moves.length; i < len; i++) {
        const ambigFrom = moves[i].from;
        const ambigTo = moves[i].to;
        const ambigPiece = moves[i].piece;
        /*
         * if a move of the same piece type ends on the same to square, we'll need
         * to add a disambiguator to the algebraic notation
         */
        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {
            ambiguities++;
            if (rank(from) === rank(ambigFrom)) {
                sameRank++;
            }
            if (file(from) === file(ambigFrom)) {
                sameFile++;
            }
        }
    }
    if (ambiguities > 0) {
        if (sameRank > 0 && sameFile > 0) {
            /*
             * if there exists a similar moving piece on the same rank and file as
             * the move in question, use the square as the disambiguator
             */
            return algebraic(from);
        }
        else if (sameFile > 0) {
            /*
             * if the moving piece rests on the same file, use the rank symbol as the
             * disambiguator
             */
            return algebraic(from).charAt(1);
        }
        else {
            // else use the file symbol
            return algebraic(from).charAt(0);
        }
    }
    return '';
}
function addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {
    const r = rank(to);
    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {
        for (let i = 0; i < PROMOTIONS.length; i++) {
            const promotion = PROMOTIONS[i];
            moves.push({
                color,
                from,
                to,
                piece,
                captured,
                promotion,
                flags: flags | BITS.PROMOTION,
            });
        }
    }
    else {
        moves.push({
            color,
            from,
            to,
            piece,
            captured,
            flags,
        });
    }
}
function inferPieceType(san) {
    let pieceType = san.charAt(0);
    if (pieceType >= 'a' && pieceType <= 'h') {
        const matches = san.match(/[a-h]\d.*[a-h]\d/);
        if (matches) {
            return undefined;
        }
        return PAWN;
    }
    pieceType = pieceType.toLowerCase();
    if (pieceType === 'o') {
        return KING;
    }
    return pieceType;
}
// parses all of the decorators out of a SAN string
function strippedSan(move) {
    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
}
class Chess {
    constructor(fen = DEFAULT_POSITION) {
        this._board = new Array(128);
        this._turn = WHITE;
        this._header = {};
        this._kings = { w: EMPTY, b: EMPTY };
        this._epSquare = -1;
        this._halfMoves = 0;
        this._moveNumber = 0;
        this._history = [];
        this._comments = {};
        this._castling = { w: 0, b: 0 };
        this.load(fen);
    }
    clear(keepHeaders = false) {
        this._board = new Array(128);
        this._kings = { w: EMPTY, b: EMPTY };
        this._turn = WHITE;
        this._castling = { w: 0, b: 0 };
        this._epSquare = EMPTY;
        this._halfMoves = 0;
        this._moveNumber = 1;
        this._history = [];
        this._comments = {};
        this._header = keepHeaders ? this._header : {};
        this._updateSetup(this.fen());
    }
    load(fen, keepHeaders = false) {
        let tokens = fen.split(/\s+/);
        // append commonly omitted fen tokens
        if (tokens.length >= 2 && tokens.length < 6) {
            const adjustments = ['-', '-', '0', '1'];
            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');
        }
        tokens = fen.split(/\s+/);
        const { ok, error } = validateFen(fen);
        if (!ok) {
            throw new Error(error);
        }
        const position = tokens[0];
        let square = 0;
        this.clear(keepHeaders);
        for (let i = 0; i < position.length; i++) {
            const piece = position.charAt(i);
            if (piece === '/') {
                square += 8;
            }
            else if (isDigit(piece)) {
                square += parseInt(piece, 10);
            }
            else {
                const color = piece < 'a' ? WHITE : BLACK;
                this.put({ type: piece.toLowerCase(), color }, algebraic(square));
                square++;
            }
        }
        this._turn = tokens[1];
        if (tokens[2].indexOf('K') > -1) {
            this._castling.w |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('Q') > -1) {
            this._castling.w |= BITS.QSIDE_CASTLE;
        }
        if (tokens[2].indexOf('k') > -1) {
            this._castling.b |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('q') > -1) {
            this._castling.b |= BITS.QSIDE_CASTLE;
        }
        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];
        this._halfMoves = parseInt(tokens[4], 10);
        this._moveNumber = parseInt(tokens[5], 10);
        this._updateSetup(this.fen());
    }
    fen() {
        var _a, _b;
        let empty = 0;
        let fen = '';
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            if (this._board[i]) {
                if (empty > 0) {
                    fen += empty;
                    empty = 0;
                }
                const { color, type: piece } = this._board[i];
                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
            }
            else {
                empty++;
            }
            if ((i + 1) & 0x88) {
                if (empty > 0) {
                    fen += empty;
                }
                if (i !== Ox88.h1) {
                    fen += '/';
                }
                empty = 0;
                i += 8;
            }
        }
        let castling = '';
        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {
            castling += 'K';
        }
        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {
            castling += 'Q';
        }
        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {
            castling += 'k';
        }
        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {
            castling += 'q';
        }
        // do we have an empty castling flag?
        castling = castling || '-';
        let epSquare = '-';
        /*
         * only print the ep square if en passant is a valid move (pawn is present
         * and ep capture is not pinned)
         */
        if (this._epSquare !== EMPTY) {
            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);
            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];
            for (const square of squares) {
                // is the square off the board?
                if (square & 0x88) {
                    continue;
                }
                const color = this._turn;
                // is there a pawn that can capture the epSquare?
                if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color &&
                    ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === PAWN) {
                    // if the pawn makes an ep capture, does it leave it's king in check?
                    this._makeMove({
                        color,
                        from: square,
                        to: this._epSquare,
                        piece: PAWN,
                        captured: PAWN,
                        flags: BITS.EP_CAPTURE,
                    });
                    const isLegal = !this._isKingAttacked(color);
                    this._undoMove();
                    // if ep is legal, break and set the ep square in the FEN output
                    if (isLegal) {
                        epSquare = algebraic(this._epSquare);
                        break;
                    }
                }
            }
        }
        return [
            fen,
            this._turn,
            castling,
            epSquare,
            this._halfMoves,
            this._moveNumber,
        ].join(' ');
    }
    /*
     * Called when the initial board setup is changed with put() or remove().
     * modifies the SetUp and FEN properties of the header object. If the FEN
     * is equal to the default position, the SetUp and FEN are deleted the setup
     * is only updated if history.length is zero, ie moves haven't been made.
     */
    _updateSetup(fen) {
        if (this._history.length > 0)
            return;
        if (fen !== DEFAULT_POSITION) {
            this._header['SetUp'] = '1';
            this._header['FEN'] = fen;
        }
        else {
            delete this._header['SetUp'];
            delete this._header['FEN'];
        }
    }
    reset() {
        this.load(DEFAULT_POSITION);
    }
    get(square) {
        return this._board[Ox88[square]] || false;
    }
    put({ type, color }, square) {
        // check for piece
        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {
            return false;
        }
        // check for valid square
        if (!(square in Ox88)) {
            return false;
        }
        const sq = Ox88[square];
        // don't let the user place more than one king
        if (type == KING &&
            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {
            return false;
        }
        this._board[sq] = { type: type, color: color };
        if (type === KING) {
            this._kings[color] = sq;
        }
        this._updateSetup(this.fen());
        return true;
    }
    remove(square) {
        const piece = this.get(square);
        delete this._board[Ox88[square]];
        if (piece && piece.type === KING) {
            this._kings[piece.color] = EMPTY;
        }
        this._updateSetup(this.fen());
        return piece;
    }
    _attacked(color, square) {
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            // did we run off the end of the board
            if (i & 0x88) {
                i += 7;
                continue;
            }
            // if empty square or wrong color
            if (this._board[i] === undefined || this._board[i].color !== color) {
                continue;
            }
            const piece = this._board[i];
            const difference = i - square;
            // skip - to/from square are the same
            if (difference === 0) {
                continue;
            }
            const index = difference + 119;
            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {
                if (piece.type === PAWN) {
                    if (difference > 0) {
                        if (piece.color === WHITE)
                            return true;
                    }
                    else {
                        if (piece.color === BLACK)
                            return true;
                    }
                    continue;
                }
                // if the piece is a knight or a king
                if (piece.type === 'n' || piece.type === 'k')
                    return true;
                const offset = RAYS[index];
                let j = i + offset;
                let blocked = false;
                while (j !== square) {
                    if (this._board[j] != null) {
                        blocked = true;
                        break;
                    }
                    j += offset;
                }
                if (!blocked)
                    return true;
            }
        }
        return false;
    }
    _isKingAttacked(color) {
        return this._attacked(swapColor(color), this._kings[color]);
    }
    isAttacked(square, attackedBy) {
        return this._attacked(attackedBy, Ox88[square]);
    }
    isCheck() {
        return this._isKingAttacked(this._turn);
    }
    inCheck() {
        return this.isCheck();
    }
    isCheckmate() {
        return this.isCheck() && this._moves().length === 0;
    }
    isStalemate() {
        return !this.isCheck() && this._moves().length === 0;
    }
    isInsufficientMaterial() {
        /*
         * k.b. vs k.b. (of opposite colors) with mate in 1:
         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1
         *
         * k.b. vs k.n. with mate in 1:
         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1
         */
        const pieces = {
            b: 0,
            n: 0,
            r: 0,
            q: 0,
            k: 0,
            p: 0,
        };
        const bishops = [];
        let numPieces = 0;
        let squareColor = 0;
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            squareColor = (squareColor + 1) % 2;
            if (i & 0x88) {
                i += 7;
                continue;
            }
            const piece = this._board[i];
            if (piece) {
                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;
                if (piece.type === BISHOP) {
                    bishops.push(squareColor);
                }
                numPieces++;
            }
        }
        // k vs. k
        if (numPieces === 2) {
            return true;
        }
        else if (
        // k vs. kn .... or .... k vs. kb
        numPieces === 3 &&
            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {
            return true;
        }
        else if (numPieces === pieces[BISHOP] + 2) {
            // kb vs. kb where any number of bishops are all on the same color
            let sum = 0;
            const len = bishops.length;
            for (let i = 0; i < len; i++) {
                sum += bishops[i];
            }
            if (sum === 0 || sum === len) {
                return true;
            }
        }
        return false;
    }
    isThreefoldRepetition() {
        const moves = [];
        const positions = {};
        let repetition = false;
        while (true) {
            const move = this._undoMove();
            if (!move)
                break;
            moves.push(move);
        }
        while (true) {
            /*
             * remove the last two fields in the FEN string, they're not needed when
             * checking for draw by rep
             */
            const fen = this.fen().split(' ').slice(0, 4).join(' ');
            // has the position occurred three or move times
            positions[fen] = fen in positions ? positions[fen] + 1 : 1;
            if (positions[fen] >= 3) {
                repetition = true;
            }
            const move = moves.pop();
            if (!move) {
                break;
            }
            else {
                this._makeMove(move);
            }
        }
        return repetition;
    }
    isDraw() {
        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves
            this.isStalemate() ||
            this.isInsufficientMaterial() ||
            this.isThreefoldRepetition());
    }
    isGameOver() {
        return this.isCheckmate() || this.isStalemate() || this.isDraw();
    }
    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {
        const moves = this._moves({ square, piece });
        if (verbose) {
            return moves.map((move) => this._makePretty(move));
        }
        else {
            return moves.map((move) => this._moveToSan(move, moves));
        }
    }
    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {
        var _a;
        const forSquare = square ? square.toLowerCase() : undefined;
        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();
        const moves = [];
        const us = this._turn;
        const them = swapColor(us);
        let firstSquare = Ox88.a8;
        let lastSquare = Ox88.h1;
        let singleSquare = false;
        // are we generating moves for a single square?
        if (forSquare) {
            // illegal square, return empty moves
            if (!(forSquare in Ox88)) {
                return [];
            }
            else {
                firstSquare = lastSquare = Ox88[forSquare];
                singleSquare = true;
            }
        }
        for (let from = firstSquare; from <= lastSquare; from++) {
            // did we run off the end of the board
            if (from & 0x88) {
                from += 7;
                continue;
            }
            // empty square or opponent, skip
            if (!this._board[from] || this._board[from].color === them) {
                continue;
            }
            const { type } = this._board[from];
            let to;
            if (type === PAWN) {
                if (forPiece && forPiece !== type)
                    continue;
                // single square, non-capturing
                to = from + PAWN_OFFSETS[us][0];
                if (!this._board[to]) {
                    addMove(moves, us, from, to, PAWN);
                    // double square
                    to = from + PAWN_OFFSETS[us][1];
                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {
                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);
                    }
                }
                // pawn captures
                for (let j = 2; j < 4; j++) {
                    to = from + PAWN_OFFSETS[us][j];
                    if (to & 0x88)
                        continue;
                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {
                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);
                    }
                    else if (to === this._epSquare) {
                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);
                    }
                }
            }
            else {
                if (forPiece && forPiece !== type)
                    continue;
                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {
                    const offset = PIECE_OFFSETS[type][j];
                    to = from;
                    while (true) {
                        to += offset;
                        if (to & 0x88)
                            break;
                        if (!this._board[to]) {
                            addMove(moves, us, from, to, type);
                        }
                        else {
                            // own color, stop loop
                            if (this._board[to].color === us)
                                break;
                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);
                            break;
                        }
                        /* break, if knight or king */
                        if (type === KNIGHT || type === KING)
                            break;
                    }
                }
            }
        }
        /*
         * check for castling if we're:
         *   a) generating all moves, or
         *   b) doing single square move generation on the king's square
         */
        if (forPiece === undefined || forPiece === KING) {
            if (!singleSquare || lastSquare === this._kings[us]) {
                // king-side castling
                if (this._castling[us] & BITS.KSIDE_CASTLE) {
                    const castlingFrom = this._kings[us];
                    const castlingTo = castlingFrom + 2;
                    if (!this._board[castlingFrom + 1] &&
                        !this._board[castlingTo] &&
                        !this._attacked(them, this._kings[us]) &&
                        !this._attacked(them, castlingFrom + 1) &&
                        !this._attacked(them, castlingTo)) {
                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);
                    }
                }
                // queen-side castling
                if (this._castling[us] & BITS.QSIDE_CASTLE) {
                    const castlingFrom = this._kings[us];
                    const castlingTo = castlingFrom - 2;
                    if (!this._board[castlingFrom - 1] &&
                        !this._board[castlingFrom - 2] &&
                        !this._board[castlingFrom - 3] &&
                        !this._attacked(them, this._kings[us]) &&
                        !this._attacked(them, castlingFrom - 1) &&
                        !this._attacked(them, castlingTo)) {
                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);
                    }
                }
            }
        }
        /*
         * return all pseudo-legal moves (this includes moves that allow the king
         * to be captured)
         */
        if (!legal) {
            return moves;
        }
        // filter out illegal moves
        const legalMoves = [];
        for (let i = 0, len = moves.length; i < len; i++) {
            this._makeMove(moves[i]);
            if (!this._isKingAttacked(us)) {
                legalMoves.push(moves[i]);
            }
            this._undoMove();
        }
        return legalMoves;
    }
    move(move, { strict = false } = {}) {
        /*
         * The move function can be called with in the following parameters:
         *
         * .move('Nxb7')       <- argument is a case-sensitive SAN string
         *
         * .move({ from: 'h7', <- argument is a move object
         *         to :'h8',
         *         promotion: 'q' })
         *
         *
         * An optional strict argument may be supplied to tell chess.js to
         * strictly follow the SAN specification.
         */
        let moveObj = null;
        if (typeof move === 'string') {
            moveObj = this._moveFromSan(move, strict);
        }
        else if (typeof move === 'object') {
            const moves = this._moves();
            // convert the pretty move object to an ugly move object
            for (let i = 0, len = moves.length; i < len; i++) {
                if (move.from === algebraic(moves[i].from) &&
                    move.to === algebraic(moves[i].to) &&
                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {
                    moveObj = moves[i];
                    break;
                }
            }
        }
        // failed to find move
        if (!moveObj) {
            if (typeof move === 'string') {
                throw new Error(`Invalid move: ${move}`);
            }
            else {
                throw new Error(`Invalid move: ${JSON.stringify(move)}`);
            }
        }
        /*
         * need to make a copy of move because we can't generate SAN after the move
         * is made
         */
        const prettyMove = this._makePretty(moveObj);
        this._makeMove(moveObj);
        return prettyMove;
    }
    _push(move) {
        this._history.push({
            move,
            kings: { b: this._kings.b, w: this._kings.w },
            turn: this._turn,
            castling: { b: this._castling.b, w: this._castling.w },
            epSquare: this._epSquare,
            halfMoves: this._halfMoves,
            moveNumber: this._moveNumber,
        });
    }
    _makeMove(move) {
        const us = this._turn;
        const them = swapColor(us);
        this._push(move);
        this._board[move.to] = this._board[move.from];
        delete this._board[move.from];
        // if ep capture, remove the captured pawn
        if (move.flags & BITS.EP_CAPTURE) {
            if (this._turn === BLACK) {
                delete this._board[move.to - 16];
            }
            else {
                delete this._board[move.to + 16];
            }
        }
        // if pawn promotion, replace with new piece
        if (move.promotion) {
            this._board[move.to] = { type: move.promotion, color: us };
        }
        // if we moved the king
        if (this._board[move.to].type === KING) {
            this._kings[us] = move.to;
            // if we castled, move the rook next to the king
            if (move.flags & BITS.KSIDE_CASTLE) {
                const castlingTo = move.to - 1;
                const castlingFrom = move.to + 1;
                this._board[castlingTo] = this._board[castlingFrom];
                delete this._board[castlingFrom];
            }
            else if (move.flags & BITS.QSIDE_CASTLE) {
                const castlingTo = move.to + 1;
                const castlingFrom = move.to - 2;
                this._board[castlingTo] = this._board[castlingFrom];
                delete this._board[castlingFrom];
            }
            // turn off castling
            this._castling[us] = 0;
        }
        // turn off castling if we move a rook
        if (this._castling[us]) {
            for (let i = 0, len = ROOKS[us].length; i < len; i++) {
                if (move.from === ROOKS[us][i].square &&
                    this._castling[us] & ROOKS[us][i].flag) {
                    this._castling[us] ^= ROOKS[us][i].flag;
                    break;
                }
            }
        }
        // turn off castling if we capture a rook
        if (this._castling[them]) {
            for (let i = 0, len = ROOKS[them].length; i < len; i++) {
                if (move.to === ROOKS[them][i].square &&
                    this._castling[them] & ROOKS[them][i].flag) {
                    this._castling[them] ^= ROOKS[them][i].flag;
                    break;
                }
            }
        }
        // if big pawn move, update the en passant square
        if (move.flags & BITS.BIG_PAWN) {
            if (us === BLACK) {
                this._epSquare = move.to - 16;
            }
            else {
                this._epSquare = move.to + 16;
            }
        }
        else {
            this._epSquare = EMPTY;
        }
        // reset the 50 move counter if a pawn is moved or a piece is captured
        if (move.piece === PAWN) {
            this._halfMoves = 0;
        }
        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
            this._halfMoves = 0;
        }
        else {
            this._halfMoves++;
        }
        if (us === BLACK) {
            this._moveNumber++;
        }
        this._turn = them;
    }
    undo() {
        const move = this._undoMove();
        return move ? this._makePretty(move) : null;
    }
    _undoMove() {
        const old = this._history.pop();
        if (old === undefined) {
            return null;
        }
        const move = old.move;
        this._kings = old.kings;
        this._turn = old.turn;
        this._castling = old.castling;
        this._epSquare = old.epSquare;
        this._halfMoves = old.halfMoves;
        this._moveNumber = old.moveNumber;
        const us = this._turn;
        const them = swapColor(us);
        this._board[move.from] = this._board[move.to];
        this._board[move.from].type = move.piece; // to undo any promotions
        delete this._board[move.to];
        if (move.captured) {
            if (move.flags & BITS.EP_CAPTURE) {
                // en passant capture
                let index;
                if (us === BLACK) {
                    index = move.to - 16;
                }
                else {
                    index = move.to + 16;
                }
                this._board[index] = { type: PAWN, color: them };
            }
            else {
                // regular capture
                this._board[move.to] = { type: move.captured, color: them };
            }
        }
        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
            let castlingTo, castlingFrom;
            if (move.flags & BITS.KSIDE_CASTLE) {
                castlingTo = move.to + 1;
                castlingFrom = move.to - 1;
            }
            else {
                castlingTo = move.to - 2;
                castlingFrom = move.to + 1;
            }
            this._board[castlingTo] = this._board[castlingFrom];
            delete this._board[castlingFrom];
        }
        return move;
    }
    pgn({ newline = '\n', maxWidth = 0, } = {}) {
        /*
         * using the specification from http://www.chessclub.com/help/PGN-spec
         * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
         */
        const result = [];
        let headerExists = false;
        /* add the PGN header information */
        for (const i in this._header) {
            /*
             * TODO: order of enumerated properties in header object is not
             * guaranteed, see ECMA-262 spec (section 12.6.4)
             */
            result.push('[' + i + ' "' + this._header[i] + '"]' + newline);
            headerExists = true;
        }
        if (headerExists && this._history.length) {
            result.push(newline);
        }
        const appendComment = (moveString) => {
            const comment = this._comments[this.fen()];
            if (typeof comment !== 'undefined') {
                const delimiter = moveString.length > 0 ? ' ' : '';
                moveString = `${moveString}${delimiter}{${comment}}`;
            }
            return moveString;
        };
        // pop all of history onto reversed_history
        const reversedHistory = [];
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        const moves = [];
        let moveString = '';
        // special case of a commented starting position with no moves
        if (reversedHistory.length === 0) {
            moves.push(appendComment(''));
        }
        // build the list of moves.  a move_string looks like: "3. e3 e6"
        while (reversedHistory.length > 0) {
            moveString = appendComment(moveString);
            const move = reversedHistory.pop();
            // make TypeScript stop complaining about move being undefined
            if (!move) {
                break;
            }
            // if the position started with black to move, start PGN with #. ...
            if (!this._history.length && move.color === 'b') {
                const prefix = `${this._moveNumber}. ...`;
                // is there a comment preceding the first move?
                moveString = moveString ? `${moveString} ${prefix}` : prefix;
            }
            else if (move.color === 'w') {
                // store the previous generated move_string if we have one
                if (moveString.length) {
                    moves.push(moveString);
                }
                moveString = this._moveNumber + '.';
            }
            moveString =
                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));
            this._makeMove(move);
        }
        // are there any other leftover moves?
        if (moveString.length) {
            moves.push(appendComment(moveString));
        }
        // is there a result?
        if (typeof this._header.Result !== 'undefined') {
            moves.push(this._header.Result);
        }
        /*
         * history should be back to what it was before we started generating PGN,
         * so join together moves
         */
        if (maxWidth === 0) {
            return result.join('') + moves.join(' ');
        }
        // TODO (jah): huh?
        const strip = function () {
            if (result.length > 0 && result[result.length - 1] === ' ') {
                result.pop();
                return true;
            }
            return false;
        };
        // NB: this does not preserve comment whitespace.
        const wrapComment = function (width, move) {
            for (const token of move.split(' ')) {
                if (!token) {
                    continue;
                }
                if (width + token.length > maxWidth) {
                    while (strip()) {
                        width--;
                    }
                    result.push(newline);
                    width = 0;
                }
                result.push(token);
                width += token.length;
                result.push(' ');
                width++;
            }
            if (strip()) {
                width--;
            }
            return width;
        };
        // wrap the PGN output at max_width
        let currentWidth = 0;
        for (let i = 0; i < moves.length; i++) {
            if (currentWidth + moves[i].length > maxWidth) {
                if (moves[i].includes('{')) {
                    currentWidth = wrapComment(currentWidth, moves[i]);
                    continue;
                }
            }
            // if the current move will push past max_width
            if (currentWidth + moves[i].length > maxWidth && i !== 0) {
                // don't end the line with whitespace
                if (result[result.length - 1] === ' ') {
                    result.pop();
                }
                result.push(newline);
                currentWidth = 0;
            }
            else if (i !== 0) {
                result.push(' ');
                currentWidth++;
            }
            result.push(moves[i]);
            currentWidth += moves[i].length;
        }
        return result.join('');
    }
    header(...args) {
        for (let i = 0; i < args.length; i += 2) {
            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {
                this._header[args[i]] = args[i + 1];
            }
        }
        return this._header;
    }
    loadPgn(pgn, { strict = false, newlineChar = '\r?\n', } = {}) {
        function mask(str) {
            return str.replace(/\\/g, '\\');
        }
        function parsePgnHeader(header) {
            const headerObj = {};
            const headers = header.split(new RegExp(mask(newlineChar)));
            let key = '';
            let value = '';
            for (let i = 0; i < headers.length; i++) {
                const regex = /^\s*\[\s*([A-Za-z]+)\s*"(.*)"\s*\]\s*$/;
                key = headers[i].replace(regex, '$1');
                value = headers[i].replace(regex, '$2');
                if (key.trim().length > 0) {
                    headerObj[key] = value;
                }
            }
            return headerObj;
        }
        // strip whitespace from head/tail of PGN block
        pgn = pgn.trim();
        /*
         * RegExp to split header. Takes advantage of the fact that header and movetext
         * will always have a blank line between them (ie, two newline_char's). Handles
         * case where movetext is empty by matching newlineChar until end of string is
         * matched - effectively trimming from the end extra newlineChar.
         *
         * With default newline_char, will equal:
         * /^(\[((?:\r?\n)|.)*\])((?:\s*\r?\n){2}|(?:\s*\r?\n)*$)/
         */
        const headerRegex = new RegExp('^(\\[((?:' +
            mask(newlineChar) +
            ')|.)*\\])' +
            '((?:\\s*' +
            mask(newlineChar) +
            '){2}|(?:\\s*' +
            mask(newlineChar) +
            ')*$)');
        // If no header given, begin with moves.
        const headerRegexResults = headerRegex.exec(pgn);
        const headerString = headerRegexResults
            ? headerRegexResults.length >= 2
                ? headerRegexResults[1]
                : ''
            : '';
        // Put the board in the starting position
        this.reset();
        // parse PGN header
        const headers = parsePgnHeader(headerString);
        let fen = '';
        for (const key in headers) {
            // check to see user is including fen (possibly with wrong tag case)
            if (key.toLowerCase() === 'fen') {
                fen = headers[key];
            }
            this.header(key, headers[key]);
        }
        /*
         * the permissive parser should attempt to load a fen tag, even if it's the
         * wrong case and doesn't include a corresponding [SetUp "1"] tag
         */
        if (!strict) {
            if (fen) {
                this.load(fen, true);
            }
        }
        else {
            /*
             * strict parser - load the starting position indicated by [Setup '1']
             * and [FEN position]
             */
            if (headers['SetUp'] === '1') {
                if (!('FEN' in headers)) {
                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');
                }
                // second argument to load: don't clear the headers
                this.load(headers['FEN'], true);
            }
        }
        /*
         * NB: the regexes below that delete move numbers, recursive annotations,
         * and numeric annotation glyphs may also match text in comments. To
         * prevent this, we transform comments by hex-encoding them in place and
         * decoding them again after the other tokens have been deleted.
         *
         * While the spec states that PGN files should be ASCII encoded, we use
         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience
         * for modern users
         */
        function toHex(s) {
            return Array.from(s)
                .map(function (c) {
                /*
                 * encodeURI doesn't transform most ASCII characters, so we handle
                 * these ourselves
                 */
                return c.charCodeAt(0) < 128
                    ? c.charCodeAt(0).toString(16)
                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();
            })
                .join('');
        }
        function fromHex(s) {
            return s.length == 0
                ? ''
                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));
        }
        const encodeComment = function (s) {
            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');
            return `{${toHex(s.slice(1, s.length - 1))}}`;
        };
        const decodeComment = function (s) {
            if (s.startsWith('{') && s.endsWith('}')) {
                return fromHex(s.slice(1, s.length - 1));
            }
        };
        // delete header to get the moves
        let ms = pgn
            .replace(headerString, '')
            .replace(
        // encode comments so they don't get deleted below
        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {
            return bracket !== undefined
                ? encodeComment(bracket)
                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);
        })
            .replace(new RegExp(mask(newlineChar), 'g'), ' ');
        // delete recursive annotation variations
        const ravRegex = /(\([^()]+\))+?/g;
        while (ravRegex.test(ms)) {
            ms = ms.replace(ravRegex, '');
        }
        // delete move numbers
        ms = ms.replace(/\d+\.(\.\.)?/g, '');
        // delete ... indicating black to move
        ms = ms.replace(/\.\.\./g, '');
        /* delete numeric annotation glyphs */
        ms = ms.replace(/\$\d+/g, '');
        // trim and get array of moves
        let moves = ms.trim().split(new RegExp(/\s+/));
        // delete empty entries
        moves = moves.filter((move) => move !== '');
        let result = '';
        for (let halfMove = 0; halfMove < moves.length; halfMove++) {
            const comment = decodeComment(moves[halfMove]);
            if (comment !== undefined) {
                this._comments[this.fen()] = comment;
                continue;
            }
            const move = this._moveFromSan(moves[halfMove], strict);
            // invalid move
            if (move == null) {
                // was the move an end of game marker
                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {
                    result = moves[halfMove];
                }
                else {
                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);
                }
            }
            else {
                // reset the end of game marker if making a valid move
                result = '';
                this._makeMove(move);
            }
        }
        /*
         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match
         * the termination marker. Only do this when headers are present, but the
         * result tag is missing
         */
        if (result && Object.keys(this._header).length && !this._header['Result']) {
            this.header('Result', result);
        }
    }
    /*
     * Convert a move from 0x88 coordinates to Standard Algebraic Notation
     * (SAN)
     *
     * @param {boolean} strict Use the strict SAN parser. It will throw errors
     * on overly disambiguated moves (see below):
     *
     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
     * 4. ... Ne7 is technically the valid SAN
     */
    _moveToSan(move, moves) {
        let output = '';
        if (move.flags & BITS.KSIDE_CASTLE) {
            output = 'O-O';
        }
        else if (move.flags & BITS.QSIDE_CASTLE) {
            output = 'O-O-O';
        }
        else {
            if (move.piece !== PAWN) {
                const disambiguator = getDisambiguator(move, moves);
                output += move.piece.toUpperCase() + disambiguator;
            }
            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
                if (move.piece === PAWN) {
                    output += algebraic(move.from)[0];
                }
                output += 'x';
            }
            output += algebraic(move.to);
            if (move.promotion) {
                output += '=' + move.promotion.toUpperCase();
            }
        }
        this._makeMove(move);
        if (this.isCheck()) {
            if (this.isCheckmate()) {
                output += '#';
            }
            else {
                output += '+';
            }
        }
        this._undoMove();
        return output;
    }
    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
    _moveFromSan(move, strict = false) {
        // strip off any move decorations: e.g Nf3+?! becomes Nf3
        const cleanMove = strippedSan(move);
        let pieceType = inferPieceType(cleanMove);
        let moves = this._moves({ legal: true, piece: pieceType });
        // strict parser
        for (let i = 0, len = moves.length; i < len; i++) {
            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {
                return moves[i];
            }
        }
        // the strict parser failed
        if (strict) {
            return null;
        }
        let piece = undefined;
        let matches = undefined;
        let from = undefined;
        let to = undefined;
        let promotion = undefined;
        /*
         * The default permissive (non-strict) parser allows the user to parse
         * non-standard chess notations. This parser is only run after the strict
         * Standard Algebraic Notation (SAN) parser has failed.
         *
         * When running the permissive parser, we'll run a regex to grab the piece, the
         * to/from square, and an optional promotion piece. This regex will
         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,
         * f7f8q, b1c3
         *
         * NOTE: Some positions and moves may be ambiguous when using the permissive
         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,
         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop
         * move). In these cases, the permissive parser will default to the most
         * basic interpretation (which is b1c3 parsing to Nc3).
         */
        let overlyDisambiguated = false;
        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/
        //     piece         from              to       promotion
        );
        if (matches) {
            piece = matches[1];
            from = matches[2];
            to = matches[3];
            promotion = matches[4];
            if (from.length == 1) {
                overlyDisambiguated = true;
            }
        }
        else {
            /*
             * The [a-h]?[1-8]? portion of the regex below handles moves that may be
             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when
             * there is one legal knight move to e7). In this case, the value of
             * 'from' variable will be a rank or file, not a square.
             */
            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);
            if (matches) {
                piece = matches[1];
                from = matches[2];
                to = matches[3];
                promotion = matches[4];
                if (from.length == 1) {
                    overlyDisambiguated = true;
                }
            }
        }
        pieceType = inferPieceType(cleanMove);
        moves = this._moves({
            legal: true,
            piece: piece ? piece : pieceType,
        });
        for (let i = 0, len = moves.length; i < len; i++) {
            if (from && to) {
                // hand-compare move properties with the results from our permissive regex
                if ((!piece || piece.toLowerCase() == moves[i].piece) &&
                    Ox88[from] == moves[i].from &&
                    Ox88[to] == moves[i].to &&
                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
                    return moves[i];
                }
                else if (overlyDisambiguated) {
                    /*
                     * SPECIAL CASE: we parsed a move string that may have an unneeded
                     * rank/file disambiguator (e.g. Nge7).  The 'from' variable will
                     */
                    const square = algebraic(moves[i].from);
                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&
                        Ox88[to] == moves[i].to &&
                        (from == square[0] || from == square[1]) &&
                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
                        return moves[i];
                    }
                }
            }
        }
        return null;
    }
    ascii() {
        let s = '   +------------------------+\n';
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            // display the rank
            if (file(i) === 0) {
                s += ' ' + '87654321'[rank(i)] + ' |';
            }
            if (this._board[i]) {
                const piece = this._board[i].type;
                const color = this._board[i].color;
                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
                s += ' ' + symbol + ' ';
            }
            else {
                s += ' . ';
            }
            if ((i + 1) & 0x88) {
                s += '|\n';
                i += 8;
            }
        }
        s += '   +------------------------+\n';
        s += '     a  b  c  d  e  f  g  h';
        return s;
    }
    perft(depth) {
        const moves = this._moves({ legal: false });
        let nodes = 0;
        const color = this._turn;
        for (let i = 0, len = moves.length; i < len; i++) {
            this._makeMove(moves[i]);
            if (!this._isKingAttacked(color)) {
                if (depth - 1 > 0) {
                    nodes += this.perft(depth - 1);
                }
                else {
                    nodes++;
                }
            }
            this._undoMove();
        }
        return nodes;
    }
    // pretty = external move object
    _makePretty(uglyMove) {
        const { color, piece, from, to, flags, captured, promotion } = uglyMove;
        let prettyFlags = '';
        for (const flag in BITS) {
            if (BITS[flag] & flags) {
                prettyFlags += FLAGS[flag];
            }
        }
        const fromAlgebraic = algebraic(from);
        const toAlgebraic = algebraic(to);
        const move = {
            color,
            piece,
            from: fromAlgebraic,
            to: toAlgebraic,
            san: this._moveToSan(uglyMove, this._moves({ legal: true })),
            flags: prettyFlags,
            lan: fromAlgebraic + toAlgebraic,
            before: this.fen(),
            after: '',
        };
        // generate the FEN for the 'after' key
        this._makeMove(uglyMove);
        move.after = this.fen();
        this._undoMove();
        if (captured) {
            move.captured = captured;
        }
        if (promotion) {
            move.promotion = promotion;
            move.lan += promotion;
        }
        return move;
    }
    turn() {
        return this._turn;
    }
    board() {
        const output = [];
        let row = [];
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            if (this._board[i] == null) {
                row.push(null);
            }
            else {
                row.push({
                    square: algebraic(i),
                    type: this._board[i].type,
                    color: this._board[i].color,
                });
            }
            if ((i + 1) & 0x88) {
                output.push(row);
                row = [];
                i += 8;
            }
        }
        return output;
    }
    squareColor(square) {
        if (square in Ox88) {
            const sq = Ox88[square];
            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';
        }
        return null;
    }
    history({ verbose = false } = {}) {
        const reversedHistory = [];
        const moveHistory = [];
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        while (true) {
            const move = reversedHistory.pop();
            if (!move) {
                break;
            }
            if (verbose) {
                moveHistory.push(this._makePretty(move));
            }
            else {
                moveHistory.push(this._moveToSan(move, this._moves()));
            }
            this._makeMove(move);
        }
        return moveHistory;
    }
    _pruneComments() {
        const reversedHistory = [];
        const currentComments = {};
        const copyComment = (fen) => {
            if (fen in this._comments) {
                currentComments[fen] = this._comments[fen];
            }
        };
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        copyComment(this.fen());
        while (true) {
            const move = reversedHistory.pop();
            if (!move) {
                break;
            }
            this._makeMove(move);
            copyComment(this.fen());
        }
        this._comments = currentComments;
    }
    getComment() {
        return this._comments[this.fen()];
    }
    setComment(comment) {
        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');
    }
    deleteComment() {
        const comment = this._comments[this.fen()];
        delete this._comments[this.fen()];
        return comment;
    }
    getComments() {
        this._pruneComments();
        return Object.keys(this._comments).map((fen) => {
            return { fen: fen, comment: this._comments[fen] };
        });
    }
    deleteComments() {
        this._pruneComments();
        return Object.keys(this._comments).map((fen) => {
            const comment = this._comments[fen];
            delete this._comments[fen];
            return { fen: fen, comment: comment };
        });
    }
}

class ChessBoard extends React.Component {
    constructor(props) {
        super(props);
        this._chess = new Chess();
        this.onClick = this.onClick.bind(this);
        this.state = {
            pieces: Array(8).fill([])
        };
    }
    render() {
        return (jsxRuntime.jsx("div", Object.assign({ style: {
                width: '100%',
                aspectRatio: '1/1',
            }, onClick: this.onClick }, { children: jsxRuntime.jsx(ChessBoardSquares, { pieces: this.state.pieces }) })));
    }
    onClick() {
    }
    updatePieces() {
        this.setState({
            pieces: this._chess.board().map(row => {
                return row.map(piece => {
                    if (piece == null)
                        return undefined;
                    return {
                        color: piece.color == "w" ? ChessColor.WHITE : ChessColor.BLACK,
                        type: ["p", "n", "b", "r", "q", "k"].indexOf(piece.type)
                    };
                });
            })
        });
    }
    componentDidMount() {
        this.updatePieces();
    }
}

exports.ChessBoard = ChessBoard;
