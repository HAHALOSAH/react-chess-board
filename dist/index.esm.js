import { jsxs, jsx } from 'react/jsx-runtime';
import React from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var Staunty = {
    bB: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m25 5.767c-2.1056 0-3.8124 0.87865-3.8121 1.9632l1.5166 2.6505c-16.049 14.089-5.707 27.135-5.707 27.135h16.006s7.0496-8.6714 0.76227-19.51l-2.989 4.8276c-0.67072 1.0833-1.9632 1.4898-2.898 0.91107-0.93477-0.57872-1.1472-1.917-0.47652-3.0003l3.8867-6.2771c-1.1073-1.3449-2.4252-2.7101-3.9926-4.0861l1.5166-2.6505c0-1.0846-1.7066-1.9632-3.8121-1.9632z", style: { fill: "#5f5955", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m25 5.767c-0.8164 0-1.5711 0.1335-2.1913 0.35847 4.3387 0.84718 4.9765 1.1195 2.5601 4.3506l3.246 3.5665c-3.6565 8.2403-1.6037 7.9919-1.6037 7.9919s0.6964-2.6485 4.1117-7.7689c-1.0722-1.2796-2.3377-2.578-3.8266-3.8851l1.5161-2.6501c1e-4 -1.0845-1.7067-1.9631-3.8123-1.9634zm8.7655 12.238-1.0091 1.5127c3.7363 8.4129-4.1347 17.997-4.1347 17.997h4.3815c0.1581 0.0339 6.958-8.8438 0.76227-19.51z", style: { fill: "#000000", opacity: .18 } }), jsx("path", { d: "m15.145 31.721c-0.2191-0.0314-3.4233-9.7859 5.7543-18.751-2.3019 1.895-7.1351 13.163-5.7543 18.751z", style: { fill: "#ffffff", opacity: .25 } }), jsx("path", { d: "m23.292 10.196-1.4772-2.5943s0.2425-0.72175 1.7808-1.0472c-1.7266 1.3502-0.988 1.6622-0.3036 3.6415z", style: { fill: "#ffffff", opacity: .25 } }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.2349-2.6723-0.1726-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2607-0.3313 0.5021-0.6131 0.8866-0.8491 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5317 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bK: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink" }, { children: [jsx("path", { d: "m27.67 15.225v-3.5436h4.4396v-4.4293h-4.9344v-3.8933h-4.366v3.8933h-4.9344v4.4293h4.4396v3.5436", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("rect", { x: "20.299", y: "14.215", width: "9.3984", height: "2.7873", ry: "1.3937", style: { fill: "#5f5955", paintOrder: "normal", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m26.416 14.215c0.72479 0 1.3082 0.62142 1.3082 1.3935 0 0.77209-0.58336 1.3935-1.3082 1.3935h1.9736c0.72478 0 1.3081-0.62144 1.3081-1.3935 0-0.77209-0.58336-1.3935-1.3081-1.3935z", style: { fill: "#000000", opacity: .18, paintOrder: "normal" } }), jsx("path", { d: "m21.631 14.842c-0.40169 0-0.72499 0.34468-0.72499 0.77259 0 0.42787 0.3233 0.77227 0.72499 0.77227h0.87379c-0.40169 0-0.72499-0.3444-0.72499-0.77227 0-0.42791 0.3233-0.77259 0.72499-0.77259z", style: { fill: "#ffffff", opacity: .25, paintOrder: "normal" } }), jsx("path", { d: "m33.635 36.986s7.776-13.318 6.6127-15.916c-1.1632-2.5964-8.4802-4.4974-15.248-4.4974-6.7677 0-14.084 1.9004-15.248 4.4974-1.1632 2.5966 6.6127 15.916 6.6127 15.916z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m24.996 16.576c15.938 2.6216 12.573 9.3539 6.6406 22.543l2.0273-1.7288s7.7472-13.723 6.5839-16.32c-1.5452-2.8334-7.5027-4.1592-15.252-4.4945z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m23.765 17.295c-3.904-0.18436-14.621 1.8014-13.503 5.0167 0.81724 3.7274 2.7544 7.244 4.5085 10.504-5.6872-10.335-5.9421-13.774 8.9943-15.521z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m23.391 3.997-0.01613 3.3123h0.54565l0.01622-3.3123zm-4.9311 3.8699-0.0075 3.2077h0.77316l0.0075-3.2077zm4.4128 3.213 0.02573 2.4859h0.52l-0.02573-2.4859z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m26.189 3.3582-1.9e-5 3.8935h0.98678l2.8e-5 -3.8935zm4.441 3.8937v4.9453h1.4802v-4.9453zm-4.4396 4.4291 2.7e-5 2.4923h1.4802l-2.8e-5 -2.4923z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#000000", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 36.457s-9.1309 0.0481-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.23495-2.6723-0.17255-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m25 37.147s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22904-0.69925 0.83943-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88663-0.84901 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.0479 11.692 1.6191c0.39104 0.24 0.59243 0.53161 0.85561 0.87009 0.0258-0.0759-0.40837-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bN: (jsx("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: jsxs("g", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", shapeRendering: "geometricPrecision" }, { children: [jsx("path", { d: "m25.192 23.015c-0.16544 6.9672-11.758 5.2189-11.516 18.104l22.86 0.1184c-2.094-6.442 9.69-25.16-11.931-32.258v-1e-4s-2.4381-2.601-5.9655-2.8237l0.2227 3.5347-4.5583 4.5816c-2.6294 3.1455-8.7347 8.3784-7.7513 9.6111 3.1158 5.3041 6.3306 4.4316 6.3306 4.4316 4.2418-4.5433 5.8193-2.0894 12.309-5.2997z", fill: "#5f5955", imageRendering: "auto", stroke: "#1e1e1e", strokeLinejoin: "round", strokeWidth: "1.2" }), jsx("path", { d: "m19.32 14.694c-0.7757 0.86088-0.6902 1.1156-0.8137 2.1503 0.8055 0.12316 1.5069 0.23982 2.2486 0.0656 2.3809-1.262 0.075-3.4026-1.4347-2.2162z", imageRendering: "auto", opacity: ".4", style: { paintOrder: "fill markers stroke" } }), jsx("path", { d: "m9.1916 22.166c-0.8496 0.4078-0.9984 0.9608-1.0565 1.4754 0.7288 0.4181 1.8765-0.1255 2.0412-1.4316l-0.9846-0.044z", imageRendering: "auto", opacity: ".35" }), jsx("path", { d: "m8.1905 25.15s0.6525 1.1374-1.1019-1.641c0.6594-1.9774 8.263-9.0796 12.438-13.534l-0.1836-3.0857s1.0689 1.6901 1.2475 3.468c-4.3898 4.39-12.22 10.833-12.824 13.213 0.023 0.6738 0.24 1.0278 0.4231 1.5797z", fill: "#fff", imageRendering: "auto", opacity: ".25" }), jsx("path", { d: "m13.26 28.257c2.0291-3.3367 8.3914-3.2239 11.932-5.2424 0.3228 0.1024 0.1304 1.3697 0.2398 1.23 0.8476-1.0903 2.9259-3.279 0.8684-6.8743 0.5214 5.9575-13.718 5.5912-15.89 10.305-0.2005 0.4355 2.1818 0.7932 2.85 0.5818z", imageRendering: "auto", opacity: ".18" }), jsx("path", { d: "m25.8 23.781c-1.0131 5.8132-9.5449 6.1169-10.988 12.641 2.8332-6.4058 10.762-5.7136 10.988-12.641z", fill: "#fff", imageRendering: "auto", opacity: ".25" }), jsx("path", { d: "m18.64 6.1556s3.051 0.73807 4.9045 3.9825c20.499 7.1536 7.6413 27.937 5.7883 31.073l7.2034 0.026c-1.9871-3.2431 9.5482-25.597-11.931-32.258-1.7757-1.0691-2.7677-2.6092-5.9655-2.8238z", imageRendering: "auto", opacity: ".18" }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.235-2.6723-0.1725-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", fill: "#5f5955", imageRendering: "auto", stroke: "#1e1e1e", strokeLinejoin: "round", strokeWidth: "1.2" }), jsx("path", { d: "m25 37.147s-8.7121-0.1373-11.624 1.6658c-0.3698 0.2291-0.6992 0.8394-0.9536 1.3902 0.2608-0.3313 0.5022-0.613 0.8867-0.849 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5316 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", fill: "#fff", imageRendering: "auto", opacity: ".25" })] })) }))),
    bP: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m21.503 27.594h6.9944m-9.4974-10.086c0 1.7315 0.7123 3.3873 1.9657 4.587l-3.6504 2.0999 0.43091 3.3988h4.3059c-0.79438 3.559-2.7548 7.3308-5.0622 8.6173s-5.2994 3.0968-4.8425 8.189l25.706 2.1e-5c0.45687-5.0922-2.5352-6.9025-4.8425-8.189-2.3074-1.2865-4.2678-5.0583-5.0622-8.6173h4.3059l0.43091-3.3988-3.6503-2.0999c1.2533-1.1996 1.9655-2.8554 1.9655-4.5869 3.11e-4 -3.3667-2.628-5.9118-6.0006-5.9118-3.3726-1.1e-5 -6.0008 2.545-6.0006 5.9117z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m24.962 11.537c1.1709-0.4586 9.5273 5.9057 0.64714 10.773l4.512 2.1-0.56221 3.125h2.6586l0.42868-3.3987-3.6504-2.0999c1.2534-1.1996 1.9618-2.5812 1.9646-4.3128-0.46888-5.4159-5.9985-6.1861-5.9985-6.1861zm-2.9485 15.998c4.5025 7.9337 9.4701 9.994 13.074 9.9646l-2.1157-1.347c-2.075-1.4895-4.7317-4.8572-5.0622-8.6177z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision", strokeWidth: .26457 } }), jsx("path", { d: "m21.983 22.213-1.647 2.3466-2.3561-0.01371 4.013-2.3234z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.307 12.267c-2.5425 0.1381-5.73 3.1733-4.3848 6.9183l0.19878 0.64312c-0.3298-3.4894 2.1268-7.1169 4.186-7.5614z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m17.863 37.625c-3.9839 2.3053-5.117 6.1402-5.117 6.1402-0.01037 0-0.54754-4.1751 3.9564-6.654 4.5039-2.4789 4.8215-6.1507 5.8602-8.8927-0.63708 3.7031-0.71573 7.1012-4.6996 9.4065z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: 0.25, shapeRendering: "geometricPrecision" } })] }))),
    bQ: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m24.959 5.0937a2.9585 3.3158 90 0 0-3.3155 2.9585 2.9585 3.3158 90 0 0 3.3155 2.9585 2.9585 3.3158 90 0 0 3.316-2.9585 2.9585 3.3158 90 0 0-3.316-2.9585z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", paintOrder: "normal", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#1e1e1e" } }), jsx("path", { d: "m24.836 5.7323c-0.37582-0.20962-3.7243 0.80586-2.1848 3.5753-0.23547-1.5446 0.43755-3.2031 2.1848-3.5753z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.959 11.011c-6.5068 0-9.5953 5.8843-9.5951 10.358h19.263c1.99e-4 -4.4741-3.1607-10.358-9.6676-10.358z", style: { fill: "#5f5955", paintOrder: "normal", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m18.161 14.977c1.0418-1.4783 2.9196-3.2199 6.8404-3.3796-0.31072 0.27709-4.7888 1.1374-6.8404 3.3796z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.836 5.0067s0.04572 0.23808-1e-4 0c2.4799 1.1289 2.0497 3.8473 0.81734 5.547 7.3536 3.8036 2.2125 8.669 2.2122 8.6681h2.7008c1.7619 1.287 7.2086-2.7409-3.8351-8.669 3.5276-3.1154 0.09642-5.6072-1.8952-5.5466z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 15.225c-1.971 0-2.3483 2.6494-4.1366 2.8592-1.8213 0.21366-3.3816-2.3114-5.2505-1.7361-1.4945 0.46001-0.77828 2.5999-1.8053 3.1752-1.4018 0.78508-3.1845-1.8324-5.2902-0.29827 6.8387 8.8288 8.0859 12.377 7.9833 18.819l16.998-9.9e-5c-0.10268-6.4426 1.1445-9.9904 7.9831-18.819-2.1056-1.5341-3.8884 1.0833-5.2901 0.29827-1.0271-0.57526-0.31082-2.7152-1.8053-3.1752-1.8688-0.57526-3.4293 1.9498-5.2506 1.7361-1.7884-0.20981-2.1655-2.8592-4.1365-2.8592z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#1e1e1e" } }), jsx("path", { d: "m9.8952 19.34c-0.13588-0.0099-0.33139 0.05615-0.45862 0.08471 3.0815 4.0999 6.5751 9.5372 7.0991 12.417-1.4062-4.9323-3.2664-9.5622-6.1403-12.472z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m39.974 18.735c-9.4852 10.003-9.9239 17.985-16.941 19.31h10.476c-0.10268-6.4427 1.1445-9.9905 7.9831-18.819 0 0-0.68803-0.75582-1.5179-0.49124z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m14.912 18.945c0.20277-0.08767 1.1841-1.8078 1.9805-1.9501-1.42-0.34555-1.6188-0.0463-1.9805 1.9501z", style: { fill: "#ffffff", opacity: 25 } }), jsx("path", { d: "m22.511 17.876c0.95342-0.84704 1.6333-2.6551 3.2379-1.8453-0.79746-0.22882-2.2148 1.0403-3.2379 1.8453z", style: { fill: "#ffffff", opacity: 25 } }), jsx("path", { d: "m31.12 18.133c0.20983 0.06994 2.1762-1.6423 2.8625-1.2176 0 0-1.4313 1.1196-2.8625 1.2176z", style: { fill: "#ffffff", opacity: 25 } }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237l27.182-1e-4c0.2349-2.6723-0.1726-5.2635-1.8999-6.3237-2.5598-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2608-0.3313 0.5021-0.613 0.8866-0.849 2.5597-1.5711 11.691-1.6192 11.691-1.6192s9.1318 0.048 11.692 1.6192c0.3911 0.24 0.5925 0.5316 0.8556 0.87 0.026-0.076-0.4083-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    bR: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m17.932 20.414c4.9056-0.74066 9.5787-0.57845 14.136 0m-17.885-10.752c-1.0592 8.7669 1.1034 10.677 3.7482 10.752l-3.3154 18.159h20.767l-3.3154-18.159c2.6448-0.0745 4.8074-1.9849 3.7482-10.752l-3.6072-0.52917-1.0733 3.6427-3.1416-0.0995-0.5222-3.754h-4.9448l-0.52127 3.754-3.142 0.0995-1.0733-3.6427z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m17.932 20.414c6.828 0 13.118 0.40763 14.948 16.572l2.3187 0.38585-3.1311-16.428c-0.03144-0.30772-6.0881-1.8224-14.136-0.52917z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m14.777 10.219 2.2766-0.28599c-1.9137 0.31197-2.3128 5.2958-2.3128 5.2958-0.23801-0.17655-0.18808-4.9033 0.03618-5.0098z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25.276 9.5507c-1.6477 0-2.5191 2.7475-2.5191 2.7475l0.33726-2.7288z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m32.671 9.8162 0.93397 0.11826c-0.78478 0.49954-1.5905 1.9884-1.5905 1.9884z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m18.472 20.964 2.6206-0.29312c-2.6206 0.29312-4.8959 13.053-4.9066 13.113z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m34.013 9.3979c0.35682 6.3635-1.9499 10.603-8.0415 10.536l4.778 0.56323c7.5226 0.30904 5.101-10.806 5.0671-10.835z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .18, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 36.457s-9.1309 0.04814-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237h27.182c0.23496-2.6723-0.17255-5.2635-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#5f5955", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#1e1e1e" } }), jsx("path", { d: "m25 37.146s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22905-0.69926 0.83944-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88664-0.84902 2.5597-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.04794 11.692 1.6191c0.39104 0.24 0.59242 0.53161 0.85561 0.87009 0.02583-0.0759-0.40837-1.1579-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", opacity: .25, shapeRendering: "geometricPrecision" } })] }))),
    wB: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m25 5.767c-2.1056 0-3.8124 0.87865-3.8121 1.9632l1.5166 2.6505c-16.049 14.089-5.707 27.135-5.707 27.135h16.006s7.0496-8.6714 0.76227-19.51l-2.989 4.8276c-0.67072 1.0833-1.9632 1.4898-2.898 0.91107-0.93477-0.57872-1.1472-1.917-0.47652-3.0003l3.8867-6.2771c-1.1073-1.3449-2.4252-2.7101-3.9926-4.0861l1.5166-2.6505c0-1.0846-1.7066-1.9632-3.8121-1.9632z", style: { fill: "#f0f0f0", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m25 5.767c-0.8164 0-1.5711 0.1335-2.1913 0.35847 4.3387 0.84718 4.9765 1.1195 2.5601 4.3506l3.246 3.5665c-3.6565 8.2403-1.6037 7.9919-1.6037 7.9919s0.6964-2.6485 4.1117-7.7689c-1.0722-1.2796-2.3377-2.578-3.8266-3.8851l1.5161-2.6501c1e-4 -1.0845-1.7067-1.9631-3.8123-1.9634zm8.7655 12.238-1.0091 1.5127c3.7363 8.4129-4.1347 17.997-4.1347 17.997h4.3815c0.1581 0.0339 6.958-8.8438 0.76227-19.51z", style: { fill: "#000000", opacity: .15 } }), jsx("path", { d: "m15.145 31.721c-0.2191-0.0314-3.4233-9.7859 5.7543-18.751-2.3019 1.895-7.1351 13.163-5.7543 18.751z", style: { fill: "#ffffff" } }), jsx("path", { d: "m23.292 10.196-1.4772-2.5943s0.2425-0.72175 1.7808-1.0472c-1.7266 1.3502-0.988 1.6622-0.3036 3.6415z", style: { fill: "#ffffff" } }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.2349-2.6723-0.1726-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2607-0.3313 0.5021-0.6131 0.8866-0.8491 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5317 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wK: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink" }, { children: [jsx("path", { d: "m27.67 15.225v-3.5436h4.4396v-4.4293h-4.9344v-3.8933h-4.366v3.8933h-4.9344v4.4293h4.4396v3.5436", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("rect", { x: "20.299", y: "14.215", width: "9.3984", height: "2.7873", ry: "1.3937", style: { fill: "#f0f0f0", paintOrder: "normal", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m26.416 14.215c0.72479 0 1.3082 0.62142 1.3082 1.3935 0 0.77209-0.58336 1.3935-1.3082 1.3935h1.9736c0.72478 0 1.3081-0.62144 1.3081-1.3935 0-0.77209-0.58336-1.3935-1.3081-1.3935z", style: { fill: "#000000", opacity: .15, paintOrder: "normal" } }), jsx("path", { d: "m21.631 14.842c-0.40169 0-0.72499 0.34468-0.72499 0.77259 0 0.42787 0.3233 0.77227 0.72499 0.77227h0.87379c-0.40169 0-0.72499-0.3444-0.72499-0.77227 0-0.42791 0.3233-0.77259 0.72499-0.77259z", style: { fill: "#ffffff", paintOrder: "normal" } }), jsx("path", { d: "m33.635 36.986s7.776-13.318 6.6127-15.916c-1.1632-2.5964-8.4802-4.4974-15.248-4.4974-6.7677 0-14.084 1.9004-15.248 4.4974-1.1632 2.5966 6.6127 15.916 6.6127 15.916z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m24.996 16.576c15.938 2.6216 12.573 9.3539 6.6406 22.543l2.0273-1.7288s7.7472-13.723 6.5839-16.32c-1.5452-2.8334-7.5027-4.1592-15.252-4.4945z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m23.765 17.295c-3.904-0.18436-14.621 1.8014-13.503 5.0167 0.81724 3.7274 2.7544 7.244 4.5085 10.504-5.6872-10.335-5.9421-13.774 8.9943-15.521z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m23.391 3.997-0.01613 3.3123h0.54565l0.01622-3.3123zm-4.9311 3.8699-0.0075 3.2077h0.77316l0.0075-3.2077zm4.4128 3.213 0.02573 2.4859h0.52l-0.02573-2.4859z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m26.189 3.3582-1.9e-5 3.8935h0.98678l2.8e-5 -3.8935zm4.441 3.8937v4.9453h1.4802v-4.9453zm-4.4396 4.4291 2.7e-5 2.4923h1.4802l-2.8e-5 -2.4923z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#000000", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 36.457s-9.1309 0.0481-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.23495-2.6723-0.17255-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m25 37.147s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22904-0.69925 0.83943-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88663-0.84901 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.0479 11.692 1.6191c0.39104 0.24 0.59243 0.53161 0.85561 0.87009 0.0258-0.0759-0.40837-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wN: (jsx("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: jsxs("g", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", shapeRendering: "geometricPrecision" }, { children: [jsx("path", { d: "m25.192 23.015c-0.16544 6.9672-11.758 5.2189-11.516 18.104l22.86 0.1184c-2.094-6.442 9.69-25.16-11.931-32.258v-1e-4s-2.4381-2.601-5.9655-2.8237l0.2227 3.5347-4.5583 4.5816c-2.6294 3.1455-8.7347 8.3784-7.7513 9.6111 3.1158 5.3041 6.3306 4.4316 6.3306 4.4316 4.2418-4.5433 5.8193-2.0894 12.309-5.2997z", fill: "#f0f0f0", imageRendering: "auto", stroke: "#3c3c3c", strokeLinejoin: "round", strokeWidth: "1.2" }), jsx("path", { d: "m19.32 14.694c-0.7757 0.86088-0.6902 1.1156-0.8137 2.1503 0.8055 0.12316 1.5069 0.23982 2.2486 0.0656 2.3809-1.262 0.075-3.4026-1.4347-2.2162z", imageRendering: "auto", opacity: ".35", style: { paintOrder: "fill markers stroke" } }), jsx("path", { d: "m9.1916 22.166c-0.8496 0.4078-0.9984 0.9608-1.0565 1.4754 0.7288 0.4181 1.8765-0.1255 2.0412-1.4316l-0.9846-0.044z", imageRendering: "auto", opacity: ".3" }), jsx("path", { d: "m8.1905 25.15s0.6525 1.1374-1.1019-1.641c0.6594-1.9774 8.263-9.0796 12.438-13.534l-0.1836-3.0857s1.0689 1.6901 1.2475 3.468c-4.3898 4.39-12.22 10.833-12.824 13.213 0.023 0.6738 0.24 1.0278 0.4231 1.5797z", fill: "#fff", imageRendering: "auto" }), jsx("path", { d: "m13.26 28.257c2.0291-3.3367 8.3914-3.2239 11.932-5.2424 0.3228 0.1024 0.1304 1.3697 0.2398 1.23 0.8476-1.0903 2.9259-3.279 0.8684-6.8743 0.5214 5.9575-13.718 5.5912-15.89 10.305-0.2005 0.4355 2.1818 0.7932 2.85 0.5818z", imageRendering: "auto", opacity: ".15" }), jsx("path", { d: "m25.8 23.781c-1.0131 5.8132-9.5449 6.1169-10.988 12.641 2.8332-6.4058 10.762-5.7136 10.988-12.641z", fill: "#fff", imageRendering: "auto" }), jsx("path", { d: "m18.64 6.1556s3.051 0.73807 4.9045 3.9825c20.499 7.1536 7.6413 27.937 5.7883 31.073l7.2034 0.026c-1.9871-3.2431 9.5482-25.597-11.931-32.258-1.7757-1.0691-2.7677-2.6092-5.9655-2.8238z", imageRendering: "auto", opacity: ".15" }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6514-1.8998 6.3237h27.182c0.235-2.6723-0.1725-5.2636-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", fill: "#f0f0f0", imageRendering: "auto", stroke: "#3c3c3c", strokeLinejoin: "round", strokeWidth: "1.2" }), jsx("path", { d: "m25 37.147s-8.7121-0.1373-11.624 1.6658c-0.3698 0.2291-0.6992 0.8394-0.9536 1.3902 0.2608-0.3313 0.5022-0.613 0.8867-0.849 2.5598-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.048 11.692 1.6191c0.391 0.24 0.5924 0.5316 0.8556 0.8701 0.026-0.076-0.4084-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", fill: "#fff", imageRendering: "auto" })] })) }))),
    wP: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m21.503 27.594h6.9944m-9.4974-10.086c0 1.7315 0.7123 3.3873 1.9657 4.587l-3.6504 2.0999 0.43091 3.3988h4.3059c-0.79438 3.559-2.7548 7.3308-5.0622 8.6173s-5.2994 3.0968-4.8425 8.189l25.706 2.1e-5c0.45687-5.0922-2.5352-6.9025-4.8425-8.189-2.3074-1.2865-4.2678-5.0583-5.0622-8.6173h4.3059l0.43091-3.3988-3.6503-2.0999c1.2533-1.1996 1.9655-2.8554 1.9655-4.5869 3.11e-4 -3.3667-2.628-5.9118-6.0006-5.9118-3.3726-1.1e-5 -6.0008 2.545-6.0006 5.9117z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m24.962 11.537c1.1709-0.4586 9.5273 5.9057 0.64714 10.773l4.512 2.1-0.56221 3.125h2.6586l0.42868-3.3987-3.6504-2.0999c1.2534-1.1996 1.9618-2.5812 1.9646-4.3128-0.46888-5.4159-5.9985-6.1861-5.9985-6.1861zm-2.9485 15.998c4.5025 7.9337 9.4701 9.994 13.074 9.9646l-2.1157-1.347c-2.075-1.4895-4.7317-4.8572-5.0622-8.6177z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision", strokeWidth: .26457 } }), jsx("path", { d: "m21.983 22.213-1.647 2.3466-2.3561-0.01371 4.013-2.3234z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.307 12.267c-2.5425 0.1381-5.73 3.1733-4.3848 6.9183l0.19878 0.64312c-0.3298-3.4894 2.1268-7.1169 4.186-7.5614z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m17.863 37.625c-3.9839 2.3053-5.117 6.1402-5.117 6.1402-0.01037 0-0.54754-4.1751 3.9564-6.654 4.5039-2.4789 4.8215-6.1507 5.8602-8.8927-0.63708 3.7031-0.71573 7.1012-4.6996 9.4065z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wQ: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m24.959 5.0937a2.9585 3.3158 90 0 0-3.3155 2.9585 2.9585 3.3158 90 0 0 3.3155 2.9585 2.9585 3.3158 90 0 0 3.316-2.9585 2.9585 3.3158 90 0 0-3.316-2.9585z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", paintOrder: "normal", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#3c3c3c" } }), jsx("path", { d: "m24.836 5.7323c-0.37582-0.20962-3.7243 0.80586-2.1848 3.5753-0.23547-1.5446 0.43755-3.2031 2.1848-3.5753z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.959 11.011c-6.5068 0-9.5953 5.8843-9.5951 10.358h19.263c1.99e-4 -4.4741-3.1607-10.358-9.6676-10.358z", style: { fill: "#f0f0f0", paintOrder: "normal", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m18.161 14.977c1.0418-1.4783 2.9196-3.2199 6.8404-3.3796-0.31072 0.27709-4.7888 1.1374-6.8404 3.3796z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m24.836 5.0067s0.04572 0.23808-1e-4 0c2.4799 1.1289 2.0497 3.8473 0.81734 5.547 7.3536 3.8036 2.2125 8.669 2.2122 8.6681h2.7008c1.7619 1.287 7.2086-2.7409-3.8351-8.669 3.5276-3.1154 0.09642-5.6072-1.8952-5.5466z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 15.225c-1.971 0-2.3483 2.6494-4.1366 2.8592-1.8213 0.21366-3.3816-2.3114-5.2505-1.7361-1.4945 0.46001-0.77828 2.5999-1.8053 3.1752-1.4018 0.78508-3.1845-1.8324-5.2902-0.29827 6.8387 8.8288 8.0859 12.377 7.9833 18.819l16.998-9.9e-5c-0.10268-6.4426 1.1445-9.9904 7.9831-18.819-2.1056-1.5341-3.8884 1.0833-5.2901 0.29827-1.0271-0.57526-0.31082-2.7152-1.8053-3.1752-1.8688-0.57526-3.4293 1.9498-5.2506 1.7361-1.7884-0.20981-2.1655-2.8592-4.1365-2.8592z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.1999, stroke: "#3c3c3c" } }), jsx("path", { d: "m9.8952 19.34c-0.13588-0.0099-0.33139 0.05615-0.45862 0.08471 3.0815 4.0999 6.5751 9.5372 7.0991 12.417-1.4062-4.9323-3.2664-9.5622-6.1403-12.472z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m39.974 18.735c-9.4852 10.003-9.9239 17.985-16.941 19.31h10.476c-0.10268-6.4427 1.1445-9.9905 7.9831-18.819 0 0-0.68803-0.75582-1.5179-0.49124z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m14.912 18.945c0.20277-0.08767 1.1841-1.8078 1.9805-1.9501-1.42-0.34555-1.6188-0.0463-1.9805 1.9501z", style: { fill: "#ffffff" } }), jsx("path", { d: "m22.511 17.876c0.95342-0.84704 1.6333-2.6551 3.2379-1.8453-0.79746-0.22882-2.2148 1.0403-3.2379 1.8453z", style: { fill: "#ffffff" } }), jsx("path", { d: "m31.12 18.133c0.20983 0.06994 2.1762-1.6423 2.8625-1.2176 0 0-1.4313 1.1196-2.8625 1.2176z", style: { fill: "#ffffff" } }), jsx("path", { d: "m25 36.457s-9.1309 0.048-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237l27.182-1e-4c0.2349-2.6723-0.1726-5.2635-1.8999-6.3237-2.5598-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m25 37.147s-8.7121-0.1374-11.624 1.6658c-0.3699 0.229-0.6993 0.8394-0.9536 1.3902 0.2608-0.3313 0.5021-0.613 0.8866-0.849 2.5597-1.5711 11.691-1.6192 11.691-1.6192s9.1318 0.048 11.692 1.6192c0.3911 0.24 0.5925 0.5316 0.8556 0.87 0.026-0.076-0.4083-1.1578-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] }))),
    wR: (jsxs("svg", Object.assign({ clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", version: "1.1", viewBox: "0 0 50 50", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "m17.932 20.414c4.9056-0.74066 9.5787-0.57845 14.136 0m-17.885-10.752c-1.0592 8.7669 1.1034 10.677 3.7482 10.752l-3.3154 18.159h20.767l-3.3154-18.159c2.6448-0.0745 4.8074-1.9849 3.7482-10.752l-3.6072-0.52917-1.0733 3.6427-3.1416-0.0995-0.5222-3.754h-4.9448l-0.52127 3.754-3.142 0.0995-1.0733-3.6427z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m17.932 20.414c6.828 0 13.118 0.40763 14.948 16.572l2.3187 0.38585-3.1311-16.428c-0.03144-0.30772-6.0881-1.8224-14.136-0.52917z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m14.777 10.219 2.2766-0.28599c-1.9137 0.31197-2.3128 5.2958-2.3128 5.2958-0.23801-0.17655-0.18808-4.9033 0.03618-5.0098z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25.276 9.5507c-1.6477 0-2.5191 2.7475-2.5191 2.7475l0.33726-2.7288z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m32.671 9.8162 0.93397 0.11826c-0.78478 0.49954-1.5905 1.9884-1.5905 1.9884z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m18.472 20.964 2.6206-0.29312c-2.6206 0.29312-4.8888 13.113-4.8888 13.113z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m34.013 9.3979c0.35682 6.3635-1.9499 10.603-8.0415 10.536l4.778 0.56323c7.5226 0.30904 5.101-10.806 5.0671-10.835z", style: { clipRule: "evenodd", fillRule: "evenodd", imageRendering: "auto", opacity: .15, shapeRendering: "geometricPrecision" } }), jsx("path", { d: "m25 36.457s-9.1309 0.04814-11.691 1.6192c-1.7273 1.0602-2.1348 3.6515-1.8998 6.3237h27.182c0.23496-2.6723-0.17255-5.2635-1.8999-6.3237-2.5597-1.5711-11.691-1.6192-11.691-1.6192z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#f0f0f0", imageRendering: "auto", shapeRendering: "geometricPrecision", strokeLinejoin: "round", strokeWidth: 1.2, stroke: "#3c3c3c" } }), jsx("path", { d: "m25 37.146s-8.7121-0.13732-11.624 1.6658c-0.36985 0.22905-0.69926 0.83944-0.95359 1.3902 0.26077-0.3313 0.50213-0.61301 0.88664-0.84902 2.5597-1.5711 11.691-1.6191 11.691-1.6191s9.1318 0.04794 11.692 1.6191c0.39104 0.24 0.59242 0.53161 0.85561 0.87009 0.02583-0.0759-0.40837-1.1579-1.1438-1.5962-2.7554-1.492-11.403-1.4808-11.403-1.4808z", style: { clipRule: "evenodd", fillRule: "evenodd", fill: "#ffffff", imageRendering: "auto", shapeRendering: "geometricPrecision" } })] })))
};

class ChessPieceIcon extends React.Component {
    render() {
        return (jsx("div", Object.assign({ style: {
                display: typeof this.props.piece == 'object' ? 'block' : 'none',
                position: "relative",
                pointerEvents: 'none',
            } }, { children: jsx("div", Object.assign({ style: {
                    filter: 'drop-shadow(0 0 0.5rem #aaaaaa)',
                    position: 'absolute',
                    margin: 'auto',
                    inset: '0',
                    pointerEvents: 'none',
                } }, { children: typeof this.props.piece == 'object' &&
                    [[
                            Staunty['wP'],
                            Staunty['wN'],
                            Staunty['wB'],
                            Staunty['wR'],
                            Staunty['wQ'],
                            Staunty['wK']
                        ], [
                            Staunty['bP'],
                            Staunty['bN'],
                            Staunty['bB'],
                            Staunty['bR'],
                            Staunty['bQ'],
                            Staunty['bK']
                        ]][this.props.piece.color][this.props.piece.type] })) })));
    }
}

class ChessBoardSquare extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        return (jsxs("div", Object.assign({ style: Object.assign(Object.assign({}, this.props.style), { backgroundColor: (this.props.square.row + this.props.square.file) % 2 === 0 ? 'white' : '#AAAAAA', border: this.props.destination ? '8px solid #FF8888AA' : '0px solid #FF8888AA', width: '100%', height: '100%', position: 'relative', boxSizing: 'border-box', transition: '0.2s' }), onMouseDown: this.props.onMouseDown, onMouseUp: this.props.onMouseUp, onMouseOver: this.props.onMouseOver, onClick: this.props.onClick, tabIndex: 0 }, { children: [jsx("div", { style: {
                        position: 'absolute',
                        inset: '0px',
                        backgroundColor: '#FF8888AA',
                        pointerEvents: 'none',
                        opacity: this.props.selected ? 1 : 0,
                        transition: '0.2s'
                    } }), jsx(ChessPieceIcon, { piece: this.props.piece })] })));
    }
}

// https://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function getElementPosition(element) {
    var box = element.getBoundingClientRect();
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
    var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
    var clientLeft = document.documentElement.clientLeft || document.body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return { x: Math.round(left), y: Math.round(top) };
}
class ChessBoardSquares extends React.Component {
    constructor(props) {
        super(props);
        this.draggedChessPieceStyles = {
            position: 'absolute',
            width: (1 / 8 * 100) + '%',
            height: (1 / 8 * 100) + '%',
            transform: 'translate(-50%, -50%)',
            pointerEvents: 'none',
        };
        this.draggedChessPiece = React.createRef();
        this.draggedChessPieceContainer = React.createRef();
        this.chessBoardSquares = React.createRef();
        this.state = {
            isDragging: false,
            willDeselect: false,
        };
        this.onSquareHover = this.onSquareHover.bind(this);
        this.onMouseOut = this.onMouseOut.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
    }
    render() {
        return (jsxs("div", Object.assign({ style: {
                display: 'grid',
                gridTemplateColumns: 'repeat(8, 1fr)',
                gridTemplateRows: 'repeat(8, 1fr)',
                width: '100%',
                height: '100%',
                alignItems: 'stretch',
                cursor: this.state.isDragging ? ('grabbing') : (this.state.selectedSquare ? (this.state.selectedSquare && this.state.hoveredSquare && (this.state.hoveredSquare.row == this.state.selectedSquare.row && this.state.hoveredSquare.file == this.state.selectedSquare.file) ? ('grab') : ('pointer')) : (this.state.hoveredSquare && this.props.pieces[this.state.hoveredSquare.row][this.state.hoveredSquare.file] ? ('pointer') : ('default'))),
            }, onMouseOut: this.onMouseOut, onMouseDown: this.onMouseDown, ref: this.chessBoardSquares }, { children: [Array(8 * 8).fill(0).map((_, i) => {
                    var _a, _b;
                    let row = (i / 8) | 0;
                    let file = i % 8;
                    let selected = ((_a = this.state.selectedSquare) === null || _a === void 0 ? void 0 : _a.row) == row && this.state.selectedSquare.file == file;
                    let destination = ((_b = this.state.destinationSquare) === null || _b === void 0 ? void 0 : _b.row) == row && this.state.destinationSquare.file == file && !selected;
                    return (jsx(ChessBoardSquare, { piece: this.props.pieces[row][file], square: { row: row, file: file }, selected: selected, destination: destination, onMouseDown: () => {
                            this.onSquareMouseDown({ row: row, file: file });
                        }, onMouseOver: () => {
                            this.onSquareHover({ row: row, file: file });
                        } }, i));
                }), jsx("div", Object.assign({ style: Object.assign(Object.assign({}, this.draggedChessPieceStyles), { display: this.state.isDragging ? 'block' : 'none' }), ref: this.draggedChessPieceContainer }, { children: jsx(ChessPieceIcon, { piece: this.state.draggedPiece, ref: this.draggedChessPiece }) }))] })));
    }
    clearSelectedSquare() {
        this.setState({
            selectedSquare: undefined
        });
    }
    setSelectedSquare(square) {
        this.setState({
            selectedSquare: square
        });
    }
    onSquareMouseDown(square) {
        if (!this.props.pieces[square.row][square.file] && !this.state.selectedSquare) {
            return;
        }
        if (this.state.isDragging && !this.state.selectedSquare) {
            this.setState({
                isDragging: false
            });
            return;
        }
        if (this.state.selectedSquare && (this.state.selectedSquare.row != square.row || this.state.selectedSquare.file != square.file)) {
            if (this.props.pieces[square.row][square.file] && (this.props.pieces[square.row][square.file]).color == (this.props.pieces[this.state.selectedSquare.row][this.state.selectedSquare.file]).color) {
                this.setState({
                    willDeselect: false
                });
            }
            else {
                if (this.props.onMove) {
                    this.props.onMove({
                        from: this.state.selectedSquare,
                        to: square
                    });
                }
                this.clearSelectedSquare();
                this.clearDestinationSquare();
                this.setState({
                    willDeselect: false
                });
                return;
            }
        }
        if (!this.state.isDragging) {
            this.setSelectedSquare(square);
            this.startDragging(square);
            this.setDestinationSquare(square);
        }
    }
    onMouseDown(e) {
        this.updateDraggedChessPieceLocation(e.nativeEvent);
    }
    onMouseUp() {
        if (this.state.isDragging && !this.state.selectedSquare) {
            this.setState({
                isDragging: false
            });
            return;
        }
        if (!this.state.selectedSquare)
            return;
        if (this.state.destinationSquare && this.props.onMove) {
            if (this.state.destinationSquare.row == this.state.selectedSquare.row && this.state.destinationSquare.file == this.state.selectedSquare.file) {
                this.stopDragging();
                if (this.state.willDeselect) {
                    this.clearSelectedSquare();
                    this.setState({
                        willDeselect: false
                    });
                }
                else {
                    this.setState({
                        willDeselect: true
                    });
                }
                this.clearDestinationSquare();
                return;
            }
            this.props.onMove({
                from: this.state.selectedSquare,
                to: this.state.destinationSquare
            });
        }
        this.clearSelectedSquare();
        this.clearDestinationSquare();
        this.stopDragging();
    }
    startDragging(square) {
        this.setState({
            isDragging: true,
            draggedPiece: this.props.pieces[square.row][square.file]
        });
    }
    stopDragging() {
        this.setState({
            isDragging: false,
            draggedPiece: undefined
        });
    }
    clearDestinationSquare() {
        this.setState({
            destinationSquare: undefined
        });
    }
    setDestinationSquare(square) {
        this.setState({
            destinationSquare: square
        });
    }
    onSquareHover(square) {
        this.setState({
            hoveredSquare: square
        });
        if (this.state.selectedSquare)
            this.setDestinationSquare(square);
    }
    onMouseMove(e) {
        this.updateDraggedChessPieceLocation(e);
    }
    updateDraggedChessPieceLocation(e) {
        if (this.draggedChessPieceContainer.current == null || this.chessBoardSquares.current == null)
            return;
        let draggedChessPiece = this.draggedChessPieceContainer.current;
        let boardPosition = getElementPosition(this.chessBoardSquares.current);
        draggedChessPiece.style.left = (e.clientX - boardPosition.x) + 'px';
        draggedChessPiece.style.top = (e.clientY - boardPosition.y) + 'px';
    }
    onMouseOut() {
        this.clearDestinationSquare();
    }
    componentDidMount() {
        document.addEventListener('mousemove', this.onMouseMove);
        document.addEventListener('mouseup', this.onMouseUp);
    }
    componentWillUnmount() {
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    }
}

var ChessColor;
(function (ChessColor) {
    ChessColor[ChessColor["WHITE"] = 0] = "WHITE";
    ChessColor[ChessColor["BLACK"] = 1] = "BLACK";
})(ChessColor || (ChessColor = {}));
var ChessPieceType;
(function (ChessPieceType) {
    ChessPieceType[ChessPieceType["PAWN"] = 0] = "PAWN";
    ChessPieceType[ChessPieceType["KNIGHT"] = 1] = "KNIGHT";
    ChessPieceType[ChessPieceType["BISHOP"] = 2] = "BISHOP";
    ChessPieceType[ChessPieceType["ROOK"] = 3] = "ROOK";
    ChessPieceType[ChessPieceType["QUEEN"] = 4] = "QUEEN";
    ChessPieceType[ChessPieceType["KING"] = 5] = "KING";
})(ChessPieceType || (ChessPieceType = {}));

class ChessBoardPromotionMenu extends React.Component {
    constructor(props) {
        super(props);
        this.backdrop = React.createRef();
        this.callbacks = [];
        this.state = {
            isOpen: false,
            color: undefined,
            file: undefined,
        };
        this.onSquareHover = this.onSquareHover.bind(this);
        this.onMouseOut = this.onMouseOut.bind(this);
        this.onSquareClick = this.onSquareClick.bind(this);
    }
    render() {
        return (jsxs("div", Object.assign({ style: {
                position: 'absolute',
                inset: '0px',
                pointerEvents: this.state.isOpen ? 'auto' : 'none',
                opacity: this.state.isOpen ? 1 : 0,
                transition: '0.2s',
            } }, { children: [jsx("div", { style: {
                        position: 'absolute',
                        inset: '0px',
                        backgroundColor: '#00000088',
                    }, ref: this.backdrop, onClick: () => {
                        this.close();
                        this.returnCallbacks(undefined);
                    } }), jsxs("div", Object.assign({ style: {
                        display: 'grid',
                        gridTemplateColumns: 'repeat(1, 1fr)',
                        gridTemplateRows: 'repeat(4, 1fr)',
                        width: (1 / 8 * 100) + '%',
                        height: (4 / 8 * 100) + '%',
                        alignItems: 'stretch',
                        cursor: 'pointer',
                        position: 'relative',
                        left: (this.state.file || 0) / 8 * 100 + '%',
                        top: (this.state.color == ChessColor.WHITE ? 0 : 4) / 8 * 100 + '%',
                        filter: 'drop-shadow(0px 0px 16px #000000)'
                    }, onMouseOut: this.onMouseOut }, { children: [jsx(ChessBoardSquare, { square: { row: this.state.color == ChessColor.WHITE ? 0 : 7, file: this.state.file || 0 }, piece: typeof this.state.color == 'number' ? { color: this.state.color, type: ChessPieceType.QUEEN } : undefined, onMouseOver: () => {
                                this.onSquareHover(0);
                            }, destination: this.state.selected == 0, onClick: () => {
                                this.onSquareClick(0);
                            }, style: { order: this.state.color == ChessColor.WHITE ? 0 : 3 } }), jsx(ChessBoardSquare, { square: { row: this.state.color == ChessColor.WHITE ? 1 : 6, file: this.state.file || 0 }, piece: typeof this.state.color == 'number' ? { color: this.state.color, type: ChessPieceType.KNIGHT } : undefined, onMouseOver: () => {
                                this.onSquareHover(1);
                            }, destination: this.state.selected == 1, onClick: () => {
                                this.onSquareClick(1);
                            }, style: { order: this.state.color == ChessColor.WHITE ? 1 : 2 } }), jsx(ChessBoardSquare, { square: { row: this.state.color == ChessColor.WHITE ? 2 : 5, file: this.state.file || 0 }, piece: typeof this.state.color == 'number' ? { color: this.state.color, type: ChessPieceType.ROOK } : undefined, onMouseOver: () => {
                                this.onSquareHover(2);
                            }, destination: this.state.selected == 2, onClick: () => {
                                this.onSquareClick(2);
                            }, style: { order: this.state.color == ChessColor.WHITE ? 2 : 1 } }), jsx(ChessBoardSquare, { square: { row: this.state.color == ChessColor.WHITE ? 3 : 4, file: this.state.file || 0 }, piece: typeof this.state.color == 'number' ? { color: this.state.color, type: ChessPieceType.BISHOP } : undefined, onMouseOver: () => {
                                this.onSquareHover(3);
                            }, destination: this.state.selected == 3, onClick: () => {
                                this.onSquareClick(3);
                            }, style: { order: this.state.color == ChessColor.WHITE ? 3 : 0 } })] }))] })));
    }
    onClick() {
    }
    close() {
        this.setState({
            isOpen: false,
        });
    }
    onSquareHover(square) {
        this.setState({
            selected: square,
        });
    }
    onSquareClick(square) {
        this.close();
        this.returnCallbacks([
            ChessPieceType.QUEEN,
            ChessPieceType.KNIGHT,
            ChessPieceType.ROOK,
            ChessPieceType.BISHOP
        ][square]);
    }
    onMouseOut() {
        this.setState({
            selected: undefined,
        });
    }
    returnCallbacks(result) {
        for (let callback of this.callbacks) {
            callback(result);
        }
        this.callbacks = [];
    }
    open(color, file, callback) {
        this.callbacks.push(callback);
        this.setState({
            isOpen: true,
            color: color,
            file: file,
        });
    }
    openAsync(color, file) {
        return new Promise((resolve) => {
            this.open(color, file, resolve);
        });
    }
}

/**
 * @license
 * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
const WHITE = 'w';
const BLACK = 'b';
const PAWN = 'p';
const KNIGHT = 'n';
const BISHOP = 'b';
const ROOK = 'r';
const QUEEN = 'q';
const KING = 'k';
const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
const EMPTY = -1;
const FLAGS = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q',
};
const BITS = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64,
};
/*
 * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM
 * ----------------------------------------------------------------------------
 * From https://github.com/jhlywa/chess.js/issues/230
 *
 * A lot of people are confused when they first see the internal representation
 * of chess.js. It uses the 0x88 Move Generation Algorithm which internally
 * stores the board as an 8x16 array. This is purely for efficiency but has a
 * couple of interesting benefits:
 *
 * 1. 0x88 offers a very inexpensive "off the board" check. Bitwise AND (&) any
 *    square with 0x88, if the result is non-zero then the square is off the
 *    board. For example, assuming a knight square A8 (0 in 0x88 notation),
 *    there are 8 possible directions in which the knight can move. These
 *    directions are relative to the 8x16 board and are stored in the
 *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two
 *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88
 *    (because of two-complement representation of -18). The non-zero result
 *    means the square is off the board and the move is illegal. Take the
 *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero
 *    means the square is on the board.
 *
 * 2. The relative distance (or difference) between two squares on a 8x16 board
 *    is unique and can be used to inexpensively determine if a piece on a
 *    square can attack any other arbitrary square. For example, let's see if a
 *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is
 *    -80. We add 119 to make the ATTACKS array index non-negative (because the
 *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a
 *    bitmask of pieces that can attack from that distance and direction.
 *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the
 *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn
 *    example, we would check to see if 24 & 0x1 is non-zero, which it is
 *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a
 *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that
 *    there are no blocking pieces between E7 and E2. That's where the RAYS
 *    array comes in. It provides an offset (in this case 16) to add to E7 (20)
 *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.
 */
// prettier-ignore
// eslint-disable-next-line
const Ox88 = {
    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,
    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,
    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,
    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,
    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,
    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,
    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,
    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
};
const PAWN_OFFSETS = {
    b: [16, 32, 17, 15],
    w: [-16, -32, -17, -15],
};
const PIECE_OFFSETS = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14],
    b: [-17, -15, 17, 15],
    r: [-16, 1, 16, -1],
    q: [-17, -16, -15, 1, 17, 16, 15, -1],
    k: [-17, -16, -15, 1, 17, 16, 15, -1],
};
// prettier-ignore
const ATTACKS = [
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,
    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,
    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20
];
// prettier-ignore
const RAYS = [
    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,
    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,
    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,
    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,
    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,
    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,
    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,
    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,
    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,
    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17
];
const PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };
const SYMBOLS = 'pnbrqkPNBRQK';
const PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];
const RANK_1 = 7;
const RANK_2 = 6;
/*
 * const RANK_3 = 5
 * const RANK_4 = 4
 * const RANK_5 = 3
 * const RANK_6 = 2
 */
const RANK_7 = 1;
const RANK_8 = 0;
const ROOKS = {
    w: [
        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },
    ],
    b: [
        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },
        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },
    ],
};
const SECOND_RANK = { b: RANK_7, w: RANK_2 };
const TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];
// Extracts the zero-based rank of an 0x88 square.
function rank(square) {
    return square >> 4;
}
// Extracts the zero-based file of an 0x88 square.
function file(square) {
    return square & 0xf;
}
function isDigit(c) {
    return '0123456789'.indexOf(c) !== -1;
}
// Converts a 0x88 square to algebraic notation.
function algebraic(square) {
    const f = file(square);
    const r = rank(square);
    return ('abcdefgh'.substring(f, f + 1) +
        '87654321'.substring(r, r + 1));
}
function swapColor(color) {
    return color === WHITE ? BLACK : WHITE;
}
function validateFen(fen) {
    // 1st criterion: 6 space-seperated fields?
    const tokens = fen.split(/\s+/);
    if (tokens.length !== 6) {
        return {
            ok: false,
            error: 'Invalid FEN: must contain six space-delimited fields',
        };
    }
    // 2nd criterion: move number field is a integer value > 0?
    const moveNumber = parseInt(tokens[5], 10);
    if (isNaN(moveNumber) || moveNumber <= 0) {
        return {
            ok: false,
            error: 'Invalid FEN: move number must be a positive integer',
        };
    }
    // 3rd criterion: half move counter is an integer >= 0?
    const halfMoves = parseInt(tokens[4], 10);
    if (isNaN(halfMoves) || halfMoves < 0) {
        return {
            ok: false,
            error: 'Invalid FEN: half move counter number must be a non-negative integer',
        };
    }
    // 4th criterion: 4th field is a valid e.p.-string?
    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };
    }
    // 5th criterion: 3th field is a valid castle-string?
    if (/[^kKqQ-]/.test(tokens[2])) {
        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };
    }
    // 6th criterion: 2nd field is "w" (white) or "b" (black)?
    if (!/^(w|b)$/.test(tokens[1])) {
        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };
    }
    // 7th criterion: 1st field contains 8 rows?
    const rows = tokens[0].split('/');
    if (rows.length !== 8) {
        return {
            ok: false,
            error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows",
        };
    }
    // 8th criterion: every row is valid?
    for (let i = 0; i < rows.length; i++) {
        // check for right sum of fields AND not two numbers in succession
        let sumFields = 0;
        let previousWasNumber = false;
        for (let k = 0; k < rows[i].length; k++) {
            if (isDigit(rows[i][k])) {
                if (previousWasNumber) {
                    return {
                        ok: false,
                        error: 'Invalid FEN: piece data is invalid (consecutive number)',
                    };
                }
                sumFields += parseInt(rows[i][k], 10);
                previousWasNumber = true;
            }
            else {
                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
                    return {
                        ok: false,
                        error: 'Invalid FEN: piece data is invalid (invalid piece)',
                    };
                }
                sumFields += 1;
                previousWasNumber = false;
            }
        }
        if (sumFields !== 8) {
            return {
                ok: false,
                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',
            };
        }
    }
    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||
        (tokens[3][1] == '6' && tokens[1] == 'b')) {
        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };
    }
    const kings = [
        { color: 'white', regex: /K/g },
        { color: 'black', regex: /k/g },
    ];
    for (const { color, regex } of kings) {
        if (!regex.test(tokens[0])) {
            return { ok: false, error: `Invalid FEN: missing ${color} king` };
        }
        if ((tokens[0].match(regex) || []).length > 1) {
            return { ok: false, error: `Invalid FEN: too many ${color} kings` };
        }
    }
    return { ok: true };
}
// this function is used to uniquely identify ambiguous moves
function getDisambiguator(move, moves) {
    const from = move.from;
    const to = move.to;
    const piece = move.piece;
    let ambiguities = 0;
    let sameRank = 0;
    let sameFile = 0;
    for (let i = 0, len = moves.length; i < len; i++) {
        const ambigFrom = moves[i].from;
        const ambigTo = moves[i].to;
        const ambigPiece = moves[i].piece;
        /*
         * if a move of the same piece type ends on the same to square, we'll need
         * to add a disambiguator to the algebraic notation
         */
        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {
            ambiguities++;
            if (rank(from) === rank(ambigFrom)) {
                sameRank++;
            }
            if (file(from) === file(ambigFrom)) {
                sameFile++;
            }
        }
    }
    if (ambiguities > 0) {
        if (sameRank > 0 && sameFile > 0) {
            /*
             * if there exists a similar moving piece on the same rank and file as
             * the move in question, use the square as the disambiguator
             */
            return algebraic(from);
        }
        else if (sameFile > 0) {
            /*
             * if the moving piece rests on the same file, use the rank symbol as the
             * disambiguator
             */
            return algebraic(from).charAt(1);
        }
        else {
            // else use the file symbol
            return algebraic(from).charAt(0);
        }
    }
    return '';
}
function addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {
    const r = rank(to);
    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {
        for (let i = 0; i < PROMOTIONS.length; i++) {
            const promotion = PROMOTIONS[i];
            moves.push({
                color,
                from,
                to,
                piece,
                captured,
                promotion,
                flags: flags | BITS.PROMOTION,
            });
        }
    }
    else {
        moves.push({
            color,
            from,
            to,
            piece,
            captured,
            flags,
        });
    }
}
function inferPieceType(san) {
    let pieceType = san.charAt(0);
    if (pieceType >= 'a' && pieceType <= 'h') {
        const matches = san.match(/[a-h]\d.*[a-h]\d/);
        if (matches) {
            return undefined;
        }
        return PAWN;
    }
    pieceType = pieceType.toLowerCase();
    if (pieceType === 'o') {
        return KING;
    }
    return pieceType;
}
// parses all of the decorators out of a SAN string
function strippedSan(move) {
    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
}
class Chess {
    constructor(fen = DEFAULT_POSITION) {
        this._board = new Array(128);
        this._turn = WHITE;
        this._header = {};
        this._kings = { w: EMPTY, b: EMPTY };
        this._epSquare = -1;
        this._halfMoves = 0;
        this._moveNumber = 0;
        this._history = [];
        this._comments = {};
        this._castling = { w: 0, b: 0 };
        this.load(fen);
    }
    clear(keepHeaders = false) {
        this._board = new Array(128);
        this._kings = { w: EMPTY, b: EMPTY };
        this._turn = WHITE;
        this._castling = { w: 0, b: 0 };
        this._epSquare = EMPTY;
        this._halfMoves = 0;
        this._moveNumber = 1;
        this._history = [];
        this._comments = {};
        this._header = keepHeaders ? this._header : {};
        this._updateSetup(this.fen());
    }
    load(fen, keepHeaders = false) {
        let tokens = fen.split(/\s+/);
        // append commonly omitted fen tokens
        if (tokens.length >= 2 && tokens.length < 6) {
            const adjustments = ['-', '-', '0', '1'];
            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');
        }
        tokens = fen.split(/\s+/);
        const { ok, error } = validateFen(fen);
        if (!ok) {
            throw new Error(error);
        }
        const position = tokens[0];
        let square = 0;
        this.clear(keepHeaders);
        for (let i = 0; i < position.length; i++) {
            const piece = position.charAt(i);
            if (piece === '/') {
                square += 8;
            }
            else if (isDigit(piece)) {
                square += parseInt(piece, 10);
            }
            else {
                const color = piece < 'a' ? WHITE : BLACK;
                this.put({ type: piece.toLowerCase(), color }, algebraic(square));
                square++;
            }
        }
        this._turn = tokens[1];
        if (tokens[2].indexOf('K') > -1) {
            this._castling.w |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('Q') > -1) {
            this._castling.w |= BITS.QSIDE_CASTLE;
        }
        if (tokens[2].indexOf('k') > -1) {
            this._castling.b |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('q') > -1) {
            this._castling.b |= BITS.QSIDE_CASTLE;
        }
        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];
        this._halfMoves = parseInt(tokens[4], 10);
        this._moveNumber = parseInt(tokens[5], 10);
        this._updateSetup(this.fen());
    }
    fen() {
        var _a, _b;
        let empty = 0;
        let fen = '';
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            if (this._board[i]) {
                if (empty > 0) {
                    fen += empty;
                    empty = 0;
                }
                const { color, type: piece } = this._board[i];
                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
            }
            else {
                empty++;
            }
            if ((i + 1) & 0x88) {
                if (empty > 0) {
                    fen += empty;
                }
                if (i !== Ox88.h1) {
                    fen += '/';
                }
                empty = 0;
                i += 8;
            }
        }
        let castling = '';
        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {
            castling += 'K';
        }
        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {
            castling += 'Q';
        }
        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {
            castling += 'k';
        }
        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {
            castling += 'q';
        }
        // do we have an empty castling flag?
        castling = castling || '-';
        let epSquare = '-';
        /*
         * only print the ep square if en passant is a valid move (pawn is present
         * and ep capture is not pinned)
         */
        if (this._epSquare !== EMPTY) {
            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);
            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];
            for (const square of squares) {
                // is the square off the board?
                if (square & 0x88) {
                    continue;
                }
                const color = this._turn;
                // is there a pawn that can capture the epSquare?
                if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color &&
                    ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === PAWN) {
                    // if the pawn makes an ep capture, does it leave it's king in check?
                    this._makeMove({
                        color,
                        from: square,
                        to: this._epSquare,
                        piece: PAWN,
                        captured: PAWN,
                        flags: BITS.EP_CAPTURE,
                    });
                    const isLegal = !this._isKingAttacked(color);
                    this._undoMove();
                    // if ep is legal, break and set the ep square in the FEN output
                    if (isLegal) {
                        epSquare = algebraic(this._epSquare);
                        break;
                    }
                }
            }
        }
        return [
            fen,
            this._turn,
            castling,
            epSquare,
            this._halfMoves,
            this._moveNumber,
        ].join(' ');
    }
    /*
     * Called when the initial board setup is changed with put() or remove().
     * modifies the SetUp and FEN properties of the header object. If the FEN
     * is equal to the default position, the SetUp and FEN are deleted the setup
     * is only updated if history.length is zero, ie moves haven't been made.
     */
    _updateSetup(fen) {
        if (this._history.length > 0)
            return;
        if (fen !== DEFAULT_POSITION) {
            this._header['SetUp'] = '1';
            this._header['FEN'] = fen;
        }
        else {
            delete this._header['SetUp'];
            delete this._header['FEN'];
        }
    }
    reset() {
        this.load(DEFAULT_POSITION);
    }
    get(square) {
        return this._board[Ox88[square]] || false;
    }
    put({ type, color }, square) {
        // check for piece
        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {
            return false;
        }
        // check for valid square
        if (!(square in Ox88)) {
            return false;
        }
        const sq = Ox88[square];
        // don't let the user place more than one king
        if (type == KING &&
            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {
            return false;
        }
        this._board[sq] = { type: type, color: color };
        if (type === KING) {
            this._kings[color] = sq;
        }
        this._updateSetup(this.fen());
        return true;
    }
    remove(square) {
        const piece = this.get(square);
        delete this._board[Ox88[square]];
        if (piece && piece.type === KING) {
            this._kings[piece.color] = EMPTY;
        }
        this._updateSetup(this.fen());
        return piece;
    }
    _attacked(color, square) {
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            // did we run off the end of the board
            if (i & 0x88) {
                i += 7;
                continue;
            }
            // if empty square or wrong color
            if (this._board[i] === undefined || this._board[i].color !== color) {
                continue;
            }
            const piece = this._board[i];
            const difference = i - square;
            // skip - to/from square are the same
            if (difference === 0) {
                continue;
            }
            const index = difference + 119;
            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {
                if (piece.type === PAWN) {
                    if (difference > 0) {
                        if (piece.color === WHITE)
                            return true;
                    }
                    else {
                        if (piece.color === BLACK)
                            return true;
                    }
                    continue;
                }
                // if the piece is a knight or a king
                if (piece.type === 'n' || piece.type === 'k')
                    return true;
                const offset = RAYS[index];
                let j = i + offset;
                let blocked = false;
                while (j !== square) {
                    if (this._board[j] != null) {
                        blocked = true;
                        break;
                    }
                    j += offset;
                }
                if (!blocked)
                    return true;
            }
        }
        return false;
    }
    _isKingAttacked(color) {
        return this._attacked(swapColor(color), this._kings[color]);
    }
    isAttacked(square, attackedBy) {
        return this._attacked(attackedBy, Ox88[square]);
    }
    isCheck() {
        return this._isKingAttacked(this._turn);
    }
    inCheck() {
        return this.isCheck();
    }
    isCheckmate() {
        return this.isCheck() && this._moves().length === 0;
    }
    isStalemate() {
        return !this.isCheck() && this._moves().length === 0;
    }
    isInsufficientMaterial() {
        /*
         * k.b. vs k.b. (of opposite colors) with mate in 1:
         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1
         *
         * k.b. vs k.n. with mate in 1:
         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1
         */
        const pieces = {
            b: 0,
            n: 0,
            r: 0,
            q: 0,
            k: 0,
            p: 0,
        };
        const bishops = [];
        let numPieces = 0;
        let squareColor = 0;
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            squareColor = (squareColor + 1) % 2;
            if (i & 0x88) {
                i += 7;
                continue;
            }
            const piece = this._board[i];
            if (piece) {
                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;
                if (piece.type === BISHOP) {
                    bishops.push(squareColor);
                }
                numPieces++;
            }
        }
        // k vs. k
        if (numPieces === 2) {
            return true;
        }
        else if (
        // k vs. kn .... or .... k vs. kb
        numPieces === 3 &&
            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {
            return true;
        }
        else if (numPieces === pieces[BISHOP] + 2) {
            // kb vs. kb where any number of bishops are all on the same color
            let sum = 0;
            const len = bishops.length;
            for (let i = 0; i < len; i++) {
                sum += bishops[i];
            }
            if (sum === 0 || sum === len) {
                return true;
            }
        }
        return false;
    }
    isThreefoldRepetition() {
        const moves = [];
        const positions = {};
        let repetition = false;
        while (true) {
            const move = this._undoMove();
            if (!move)
                break;
            moves.push(move);
        }
        while (true) {
            /*
             * remove the last two fields in the FEN string, they're not needed when
             * checking for draw by rep
             */
            const fen = this.fen().split(' ').slice(0, 4).join(' ');
            // has the position occurred three or move times
            positions[fen] = fen in positions ? positions[fen] + 1 : 1;
            if (positions[fen] >= 3) {
                repetition = true;
            }
            const move = moves.pop();
            if (!move) {
                break;
            }
            else {
                this._makeMove(move);
            }
        }
        return repetition;
    }
    isDraw() {
        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves
            this.isStalemate() ||
            this.isInsufficientMaterial() ||
            this.isThreefoldRepetition());
    }
    isGameOver() {
        return this.isCheckmate() || this.isStalemate() || this.isDraw();
    }
    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {
        const moves = this._moves({ square, piece });
        if (verbose) {
            return moves.map((move) => this._makePretty(move));
        }
        else {
            return moves.map((move) => this._moveToSan(move, moves));
        }
    }
    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {
        var _a;
        const forSquare = square ? square.toLowerCase() : undefined;
        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();
        const moves = [];
        const us = this._turn;
        const them = swapColor(us);
        let firstSquare = Ox88.a8;
        let lastSquare = Ox88.h1;
        let singleSquare = false;
        // are we generating moves for a single square?
        if (forSquare) {
            // illegal square, return empty moves
            if (!(forSquare in Ox88)) {
                return [];
            }
            else {
                firstSquare = lastSquare = Ox88[forSquare];
                singleSquare = true;
            }
        }
        for (let from = firstSquare; from <= lastSquare; from++) {
            // did we run off the end of the board
            if (from & 0x88) {
                from += 7;
                continue;
            }
            // empty square or opponent, skip
            if (!this._board[from] || this._board[from].color === them) {
                continue;
            }
            const { type } = this._board[from];
            let to;
            if (type === PAWN) {
                if (forPiece && forPiece !== type)
                    continue;
                // single square, non-capturing
                to = from + PAWN_OFFSETS[us][0];
                if (!this._board[to]) {
                    addMove(moves, us, from, to, PAWN);
                    // double square
                    to = from + PAWN_OFFSETS[us][1];
                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {
                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);
                    }
                }
                // pawn captures
                for (let j = 2; j < 4; j++) {
                    to = from + PAWN_OFFSETS[us][j];
                    if (to & 0x88)
                        continue;
                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {
                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);
                    }
                    else if (to === this._epSquare) {
                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);
                    }
                }
            }
            else {
                if (forPiece && forPiece !== type)
                    continue;
                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {
                    const offset = PIECE_OFFSETS[type][j];
                    to = from;
                    while (true) {
                        to += offset;
                        if (to & 0x88)
                            break;
                        if (!this._board[to]) {
                            addMove(moves, us, from, to, type);
                        }
                        else {
                            // own color, stop loop
                            if (this._board[to].color === us)
                                break;
                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);
                            break;
                        }
                        /* break, if knight or king */
                        if (type === KNIGHT || type === KING)
                            break;
                    }
                }
            }
        }
        /*
         * check for castling if we're:
         *   a) generating all moves, or
         *   b) doing single square move generation on the king's square
         */
        if (forPiece === undefined || forPiece === KING) {
            if (!singleSquare || lastSquare === this._kings[us]) {
                // king-side castling
                if (this._castling[us] & BITS.KSIDE_CASTLE) {
                    const castlingFrom = this._kings[us];
                    const castlingTo = castlingFrom + 2;
                    if (!this._board[castlingFrom + 1] &&
                        !this._board[castlingTo] &&
                        !this._attacked(them, this._kings[us]) &&
                        !this._attacked(them, castlingFrom + 1) &&
                        !this._attacked(them, castlingTo)) {
                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);
                    }
                }
                // queen-side castling
                if (this._castling[us] & BITS.QSIDE_CASTLE) {
                    const castlingFrom = this._kings[us];
                    const castlingTo = castlingFrom - 2;
                    if (!this._board[castlingFrom - 1] &&
                        !this._board[castlingFrom - 2] &&
                        !this._board[castlingFrom - 3] &&
                        !this._attacked(them, this._kings[us]) &&
                        !this._attacked(them, castlingFrom - 1) &&
                        !this._attacked(them, castlingTo)) {
                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);
                    }
                }
            }
        }
        /*
         * return all pseudo-legal moves (this includes moves that allow the king
         * to be captured)
         */
        if (!legal) {
            return moves;
        }
        // filter out illegal moves
        const legalMoves = [];
        for (let i = 0, len = moves.length; i < len; i++) {
            this._makeMove(moves[i]);
            if (!this._isKingAttacked(us)) {
                legalMoves.push(moves[i]);
            }
            this._undoMove();
        }
        return legalMoves;
    }
    move(move, { strict = false } = {}) {
        /*
         * The move function can be called with in the following parameters:
         *
         * .move('Nxb7')       <- argument is a case-sensitive SAN string
         *
         * .move({ from: 'h7', <- argument is a move object
         *         to :'h8',
         *         promotion: 'q' })
         *
         *
         * An optional strict argument may be supplied to tell chess.js to
         * strictly follow the SAN specification.
         */
        let moveObj = null;
        if (typeof move === 'string') {
            moveObj = this._moveFromSan(move, strict);
        }
        else if (typeof move === 'object') {
            const moves = this._moves();
            // convert the pretty move object to an ugly move object
            for (let i = 0, len = moves.length; i < len; i++) {
                if (move.from === algebraic(moves[i].from) &&
                    move.to === algebraic(moves[i].to) &&
                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {
                    moveObj = moves[i];
                    break;
                }
            }
        }
        // failed to find move
        if (!moveObj) {
            if (typeof move === 'string') {
                throw new Error(`Invalid move: ${move}`);
            }
            else {
                throw new Error(`Invalid move: ${JSON.stringify(move)}`);
            }
        }
        /*
         * need to make a copy of move because we can't generate SAN after the move
         * is made
         */
        const prettyMove = this._makePretty(moveObj);
        this._makeMove(moveObj);
        return prettyMove;
    }
    _push(move) {
        this._history.push({
            move,
            kings: { b: this._kings.b, w: this._kings.w },
            turn: this._turn,
            castling: { b: this._castling.b, w: this._castling.w },
            epSquare: this._epSquare,
            halfMoves: this._halfMoves,
            moveNumber: this._moveNumber,
        });
    }
    _makeMove(move) {
        const us = this._turn;
        const them = swapColor(us);
        this._push(move);
        this._board[move.to] = this._board[move.from];
        delete this._board[move.from];
        // if ep capture, remove the captured pawn
        if (move.flags & BITS.EP_CAPTURE) {
            if (this._turn === BLACK) {
                delete this._board[move.to - 16];
            }
            else {
                delete this._board[move.to + 16];
            }
        }
        // if pawn promotion, replace with new piece
        if (move.promotion) {
            this._board[move.to] = { type: move.promotion, color: us };
        }
        // if we moved the king
        if (this._board[move.to].type === KING) {
            this._kings[us] = move.to;
            // if we castled, move the rook next to the king
            if (move.flags & BITS.KSIDE_CASTLE) {
                const castlingTo = move.to - 1;
                const castlingFrom = move.to + 1;
                this._board[castlingTo] = this._board[castlingFrom];
                delete this._board[castlingFrom];
            }
            else if (move.flags & BITS.QSIDE_CASTLE) {
                const castlingTo = move.to + 1;
                const castlingFrom = move.to - 2;
                this._board[castlingTo] = this._board[castlingFrom];
                delete this._board[castlingFrom];
            }
            // turn off castling
            this._castling[us] = 0;
        }
        // turn off castling if we move a rook
        if (this._castling[us]) {
            for (let i = 0, len = ROOKS[us].length; i < len; i++) {
                if (move.from === ROOKS[us][i].square &&
                    this._castling[us] & ROOKS[us][i].flag) {
                    this._castling[us] ^= ROOKS[us][i].flag;
                    break;
                }
            }
        }
        // turn off castling if we capture a rook
        if (this._castling[them]) {
            for (let i = 0, len = ROOKS[them].length; i < len; i++) {
                if (move.to === ROOKS[them][i].square &&
                    this._castling[them] & ROOKS[them][i].flag) {
                    this._castling[them] ^= ROOKS[them][i].flag;
                    break;
                }
            }
        }
        // if big pawn move, update the en passant square
        if (move.flags & BITS.BIG_PAWN) {
            if (us === BLACK) {
                this._epSquare = move.to - 16;
            }
            else {
                this._epSquare = move.to + 16;
            }
        }
        else {
            this._epSquare = EMPTY;
        }
        // reset the 50 move counter if a pawn is moved or a piece is captured
        if (move.piece === PAWN) {
            this._halfMoves = 0;
        }
        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
            this._halfMoves = 0;
        }
        else {
            this._halfMoves++;
        }
        if (us === BLACK) {
            this._moveNumber++;
        }
        this._turn = them;
    }
    undo() {
        const move = this._undoMove();
        return move ? this._makePretty(move) : null;
    }
    _undoMove() {
        const old = this._history.pop();
        if (old === undefined) {
            return null;
        }
        const move = old.move;
        this._kings = old.kings;
        this._turn = old.turn;
        this._castling = old.castling;
        this._epSquare = old.epSquare;
        this._halfMoves = old.halfMoves;
        this._moveNumber = old.moveNumber;
        const us = this._turn;
        const them = swapColor(us);
        this._board[move.from] = this._board[move.to];
        this._board[move.from].type = move.piece; // to undo any promotions
        delete this._board[move.to];
        if (move.captured) {
            if (move.flags & BITS.EP_CAPTURE) {
                // en passant capture
                let index;
                if (us === BLACK) {
                    index = move.to - 16;
                }
                else {
                    index = move.to + 16;
                }
                this._board[index] = { type: PAWN, color: them };
            }
            else {
                // regular capture
                this._board[move.to] = { type: move.captured, color: them };
            }
        }
        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
            let castlingTo, castlingFrom;
            if (move.flags & BITS.KSIDE_CASTLE) {
                castlingTo = move.to + 1;
                castlingFrom = move.to - 1;
            }
            else {
                castlingTo = move.to - 2;
                castlingFrom = move.to + 1;
            }
            this._board[castlingTo] = this._board[castlingFrom];
            delete this._board[castlingFrom];
        }
        return move;
    }
    pgn({ newline = '\n', maxWidth = 0, } = {}) {
        /*
         * using the specification from http://www.chessclub.com/help/PGN-spec
         * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
         */
        const result = [];
        let headerExists = false;
        /* add the PGN header information */
        for (const i in this._header) {
            /*
             * TODO: order of enumerated properties in header object is not
             * guaranteed, see ECMA-262 spec (section 12.6.4)
             */
            result.push('[' + i + ' "' + this._header[i] + '"]' + newline);
            headerExists = true;
        }
        if (headerExists && this._history.length) {
            result.push(newline);
        }
        const appendComment = (moveString) => {
            const comment = this._comments[this.fen()];
            if (typeof comment !== 'undefined') {
                const delimiter = moveString.length > 0 ? ' ' : '';
                moveString = `${moveString}${delimiter}{${comment}}`;
            }
            return moveString;
        };
        // pop all of history onto reversed_history
        const reversedHistory = [];
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        const moves = [];
        let moveString = '';
        // special case of a commented starting position with no moves
        if (reversedHistory.length === 0) {
            moves.push(appendComment(''));
        }
        // build the list of moves.  a move_string looks like: "3. e3 e6"
        while (reversedHistory.length > 0) {
            moveString = appendComment(moveString);
            const move = reversedHistory.pop();
            // make TypeScript stop complaining about move being undefined
            if (!move) {
                break;
            }
            // if the position started with black to move, start PGN with #. ...
            if (!this._history.length && move.color === 'b') {
                const prefix = `${this._moveNumber}. ...`;
                // is there a comment preceding the first move?
                moveString = moveString ? `${moveString} ${prefix}` : prefix;
            }
            else if (move.color === 'w') {
                // store the previous generated move_string if we have one
                if (moveString.length) {
                    moves.push(moveString);
                }
                moveString = this._moveNumber + '.';
            }
            moveString =
                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));
            this._makeMove(move);
        }
        // are there any other leftover moves?
        if (moveString.length) {
            moves.push(appendComment(moveString));
        }
        // is there a result?
        if (typeof this._header.Result !== 'undefined') {
            moves.push(this._header.Result);
        }
        /*
         * history should be back to what it was before we started generating PGN,
         * so join together moves
         */
        if (maxWidth === 0) {
            return result.join('') + moves.join(' ');
        }
        // TODO (jah): huh?
        const strip = function () {
            if (result.length > 0 && result[result.length - 1] === ' ') {
                result.pop();
                return true;
            }
            return false;
        };
        // NB: this does not preserve comment whitespace.
        const wrapComment = function (width, move) {
            for (const token of move.split(' ')) {
                if (!token) {
                    continue;
                }
                if (width + token.length > maxWidth) {
                    while (strip()) {
                        width--;
                    }
                    result.push(newline);
                    width = 0;
                }
                result.push(token);
                width += token.length;
                result.push(' ');
                width++;
            }
            if (strip()) {
                width--;
            }
            return width;
        };
        // wrap the PGN output at max_width
        let currentWidth = 0;
        for (let i = 0; i < moves.length; i++) {
            if (currentWidth + moves[i].length > maxWidth) {
                if (moves[i].includes('{')) {
                    currentWidth = wrapComment(currentWidth, moves[i]);
                    continue;
                }
            }
            // if the current move will push past max_width
            if (currentWidth + moves[i].length > maxWidth && i !== 0) {
                // don't end the line with whitespace
                if (result[result.length - 1] === ' ') {
                    result.pop();
                }
                result.push(newline);
                currentWidth = 0;
            }
            else if (i !== 0) {
                result.push(' ');
                currentWidth++;
            }
            result.push(moves[i]);
            currentWidth += moves[i].length;
        }
        return result.join('');
    }
    header(...args) {
        for (let i = 0; i < args.length; i += 2) {
            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {
                this._header[args[i]] = args[i + 1];
            }
        }
        return this._header;
    }
    loadPgn(pgn, { strict = false, newlineChar = '\r?\n', } = {}) {
        function mask(str) {
            return str.replace(/\\/g, '\\');
        }
        function parsePgnHeader(header) {
            const headerObj = {};
            const headers = header.split(new RegExp(mask(newlineChar)));
            let key = '';
            let value = '';
            for (let i = 0; i < headers.length; i++) {
                const regex = /^\s*\[\s*([A-Za-z]+)\s*"(.*)"\s*\]\s*$/;
                key = headers[i].replace(regex, '$1');
                value = headers[i].replace(regex, '$2');
                if (key.trim().length > 0) {
                    headerObj[key] = value;
                }
            }
            return headerObj;
        }
        // strip whitespace from head/tail of PGN block
        pgn = pgn.trim();
        /*
         * RegExp to split header. Takes advantage of the fact that header and movetext
         * will always have a blank line between them (ie, two newline_char's). Handles
         * case where movetext is empty by matching newlineChar until end of string is
         * matched - effectively trimming from the end extra newlineChar.
         *
         * With default newline_char, will equal:
         * /^(\[((?:\r?\n)|.)*\])((?:\s*\r?\n){2}|(?:\s*\r?\n)*$)/
         */
        const headerRegex = new RegExp('^(\\[((?:' +
            mask(newlineChar) +
            ')|.)*\\])' +
            '((?:\\s*' +
            mask(newlineChar) +
            '){2}|(?:\\s*' +
            mask(newlineChar) +
            ')*$)');
        // If no header given, begin with moves.
        const headerRegexResults = headerRegex.exec(pgn);
        const headerString = headerRegexResults
            ? headerRegexResults.length >= 2
                ? headerRegexResults[1]
                : ''
            : '';
        // Put the board in the starting position
        this.reset();
        // parse PGN header
        const headers = parsePgnHeader(headerString);
        let fen = '';
        for (const key in headers) {
            // check to see user is including fen (possibly with wrong tag case)
            if (key.toLowerCase() === 'fen') {
                fen = headers[key];
            }
            this.header(key, headers[key]);
        }
        /*
         * the permissive parser should attempt to load a fen tag, even if it's the
         * wrong case and doesn't include a corresponding [SetUp "1"] tag
         */
        if (!strict) {
            if (fen) {
                this.load(fen, true);
            }
        }
        else {
            /*
             * strict parser - load the starting position indicated by [Setup '1']
             * and [FEN position]
             */
            if (headers['SetUp'] === '1') {
                if (!('FEN' in headers)) {
                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');
                }
                // second argument to load: don't clear the headers
                this.load(headers['FEN'], true);
            }
        }
        /*
         * NB: the regexes below that delete move numbers, recursive annotations,
         * and numeric annotation glyphs may also match text in comments. To
         * prevent this, we transform comments by hex-encoding them in place and
         * decoding them again after the other tokens have been deleted.
         *
         * While the spec states that PGN files should be ASCII encoded, we use
         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience
         * for modern users
         */
        function toHex(s) {
            return Array.from(s)
                .map(function (c) {
                /*
                 * encodeURI doesn't transform most ASCII characters, so we handle
                 * these ourselves
                 */
                return c.charCodeAt(0) < 128
                    ? c.charCodeAt(0).toString(16)
                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();
            })
                .join('');
        }
        function fromHex(s) {
            return s.length == 0
                ? ''
                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));
        }
        const encodeComment = function (s) {
            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');
            return `{${toHex(s.slice(1, s.length - 1))}}`;
        };
        const decodeComment = function (s) {
            if (s.startsWith('{') && s.endsWith('}')) {
                return fromHex(s.slice(1, s.length - 1));
            }
        };
        // delete header to get the moves
        let ms = pgn
            .replace(headerString, '')
            .replace(
        // encode comments so they don't get deleted below
        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {
            return bracket !== undefined
                ? encodeComment(bracket)
                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);
        })
            .replace(new RegExp(mask(newlineChar), 'g'), ' ');
        // delete recursive annotation variations
        const ravRegex = /(\([^()]+\))+?/g;
        while (ravRegex.test(ms)) {
            ms = ms.replace(ravRegex, '');
        }
        // delete move numbers
        ms = ms.replace(/\d+\.(\.\.)?/g, '');
        // delete ... indicating black to move
        ms = ms.replace(/\.\.\./g, '');
        /* delete numeric annotation glyphs */
        ms = ms.replace(/\$\d+/g, '');
        // trim and get array of moves
        let moves = ms.trim().split(new RegExp(/\s+/));
        // delete empty entries
        moves = moves.filter((move) => move !== '');
        let result = '';
        for (let halfMove = 0; halfMove < moves.length; halfMove++) {
            const comment = decodeComment(moves[halfMove]);
            if (comment !== undefined) {
                this._comments[this.fen()] = comment;
                continue;
            }
            const move = this._moveFromSan(moves[halfMove], strict);
            // invalid move
            if (move == null) {
                // was the move an end of game marker
                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {
                    result = moves[halfMove];
                }
                else {
                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);
                }
            }
            else {
                // reset the end of game marker if making a valid move
                result = '';
                this._makeMove(move);
            }
        }
        /*
         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match
         * the termination marker. Only do this when headers are present, but the
         * result tag is missing
         */
        if (result && Object.keys(this._header).length && !this._header['Result']) {
            this.header('Result', result);
        }
    }
    /*
     * Convert a move from 0x88 coordinates to Standard Algebraic Notation
     * (SAN)
     *
     * @param {boolean} strict Use the strict SAN parser. It will throw errors
     * on overly disambiguated moves (see below):
     *
     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
     * 4. ... Ne7 is technically the valid SAN
     */
    _moveToSan(move, moves) {
        let output = '';
        if (move.flags & BITS.KSIDE_CASTLE) {
            output = 'O-O';
        }
        else if (move.flags & BITS.QSIDE_CASTLE) {
            output = 'O-O-O';
        }
        else {
            if (move.piece !== PAWN) {
                const disambiguator = getDisambiguator(move, moves);
                output += move.piece.toUpperCase() + disambiguator;
            }
            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
                if (move.piece === PAWN) {
                    output += algebraic(move.from)[0];
                }
                output += 'x';
            }
            output += algebraic(move.to);
            if (move.promotion) {
                output += '=' + move.promotion.toUpperCase();
            }
        }
        this._makeMove(move);
        if (this.isCheck()) {
            if (this.isCheckmate()) {
                output += '#';
            }
            else {
                output += '+';
            }
        }
        this._undoMove();
        return output;
    }
    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
    _moveFromSan(move, strict = false) {
        // strip off any move decorations: e.g Nf3+?! becomes Nf3
        const cleanMove = strippedSan(move);
        let pieceType = inferPieceType(cleanMove);
        let moves = this._moves({ legal: true, piece: pieceType });
        // strict parser
        for (let i = 0, len = moves.length; i < len; i++) {
            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {
                return moves[i];
            }
        }
        // the strict parser failed
        if (strict) {
            return null;
        }
        let piece = undefined;
        let matches = undefined;
        let from = undefined;
        let to = undefined;
        let promotion = undefined;
        /*
         * The default permissive (non-strict) parser allows the user to parse
         * non-standard chess notations. This parser is only run after the strict
         * Standard Algebraic Notation (SAN) parser has failed.
         *
         * When running the permissive parser, we'll run a regex to grab the piece, the
         * to/from square, and an optional promotion piece. This regex will
         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,
         * f7f8q, b1c3
         *
         * NOTE: Some positions and moves may be ambiguous when using the permissive
         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,
         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop
         * move). In these cases, the permissive parser will default to the most
         * basic interpretation (which is b1c3 parsing to Nc3).
         */
        let overlyDisambiguated = false;
        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/
        //     piece         from              to       promotion
        );
        if (matches) {
            piece = matches[1];
            from = matches[2];
            to = matches[3];
            promotion = matches[4];
            if (from.length == 1) {
                overlyDisambiguated = true;
            }
        }
        else {
            /*
             * The [a-h]?[1-8]? portion of the regex below handles moves that may be
             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when
             * there is one legal knight move to e7). In this case, the value of
             * 'from' variable will be a rank or file, not a square.
             */
            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);
            if (matches) {
                piece = matches[1];
                from = matches[2];
                to = matches[3];
                promotion = matches[4];
                if (from.length == 1) {
                    overlyDisambiguated = true;
                }
            }
        }
        pieceType = inferPieceType(cleanMove);
        moves = this._moves({
            legal: true,
            piece: piece ? piece : pieceType,
        });
        for (let i = 0, len = moves.length; i < len; i++) {
            if (from && to) {
                // hand-compare move properties with the results from our permissive regex
                if ((!piece || piece.toLowerCase() == moves[i].piece) &&
                    Ox88[from] == moves[i].from &&
                    Ox88[to] == moves[i].to &&
                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
                    return moves[i];
                }
                else if (overlyDisambiguated) {
                    /*
                     * SPECIAL CASE: we parsed a move string that may have an unneeded
                     * rank/file disambiguator (e.g. Nge7).  The 'from' variable will
                     */
                    const square = algebraic(moves[i].from);
                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&
                        Ox88[to] == moves[i].to &&
                        (from == square[0] || from == square[1]) &&
                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
                        return moves[i];
                    }
                }
            }
        }
        return null;
    }
    ascii() {
        let s = '   +------------------------+\n';
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            // display the rank
            if (file(i) === 0) {
                s += ' ' + '87654321'[rank(i)] + ' |';
            }
            if (this._board[i]) {
                const piece = this._board[i].type;
                const color = this._board[i].color;
                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
                s += ' ' + symbol + ' ';
            }
            else {
                s += ' . ';
            }
            if ((i + 1) & 0x88) {
                s += '|\n';
                i += 8;
            }
        }
        s += '   +------------------------+\n';
        s += '     a  b  c  d  e  f  g  h';
        return s;
    }
    perft(depth) {
        const moves = this._moves({ legal: false });
        let nodes = 0;
        const color = this._turn;
        for (let i = 0, len = moves.length; i < len; i++) {
            this._makeMove(moves[i]);
            if (!this._isKingAttacked(color)) {
                if (depth - 1 > 0) {
                    nodes += this.perft(depth - 1);
                }
                else {
                    nodes++;
                }
            }
            this._undoMove();
        }
        return nodes;
    }
    // pretty = external move object
    _makePretty(uglyMove) {
        const { color, piece, from, to, flags, captured, promotion } = uglyMove;
        let prettyFlags = '';
        for (const flag in BITS) {
            if (BITS[flag] & flags) {
                prettyFlags += FLAGS[flag];
            }
        }
        const fromAlgebraic = algebraic(from);
        const toAlgebraic = algebraic(to);
        const move = {
            color,
            piece,
            from: fromAlgebraic,
            to: toAlgebraic,
            san: this._moveToSan(uglyMove, this._moves({ legal: true })),
            flags: prettyFlags,
            lan: fromAlgebraic + toAlgebraic,
            before: this.fen(),
            after: '',
        };
        // generate the FEN for the 'after' key
        this._makeMove(uglyMove);
        move.after = this.fen();
        this._undoMove();
        if (captured) {
            move.captured = captured;
        }
        if (promotion) {
            move.promotion = promotion;
            move.lan += promotion;
        }
        return move;
    }
    turn() {
        return this._turn;
    }
    board() {
        const output = [];
        let row = [];
        for (let i = Ox88.a8; i <= Ox88.h1; i++) {
            if (this._board[i] == null) {
                row.push(null);
            }
            else {
                row.push({
                    square: algebraic(i),
                    type: this._board[i].type,
                    color: this._board[i].color,
                });
            }
            if ((i + 1) & 0x88) {
                output.push(row);
                row = [];
                i += 8;
            }
        }
        return output;
    }
    squareColor(square) {
        if (square in Ox88) {
            const sq = Ox88[square];
            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';
        }
        return null;
    }
    history({ verbose = false } = {}) {
        const reversedHistory = [];
        const moveHistory = [];
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        while (true) {
            const move = reversedHistory.pop();
            if (!move) {
                break;
            }
            if (verbose) {
                moveHistory.push(this._makePretty(move));
            }
            else {
                moveHistory.push(this._moveToSan(move, this._moves()));
            }
            this._makeMove(move);
        }
        return moveHistory;
    }
    _pruneComments() {
        const reversedHistory = [];
        const currentComments = {};
        const copyComment = (fen) => {
            if (fen in this._comments) {
                currentComments[fen] = this._comments[fen];
            }
        };
        while (this._history.length > 0) {
            reversedHistory.push(this._undoMove());
        }
        copyComment(this.fen());
        while (true) {
            const move = reversedHistory.pop();
            if (!move) {
                break;
            }
            this._makeMove(move);
            copyComment(this.fen());
        }
        this._comments = currentComments;
    }
    getComment() {
        return this._comments[this.fen()];
    }
    setComment(comment) {
        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');
    }
    deleteComment() {
        const comment = this._comments[this.fen()];
        delete this._comments[this.fen()];
        return comment;
    }
    getComments() {
        this._pruneComments();
        return Object.keys(this._comments).map((fen) => {
            return { fen: fen, comment: this._comments[fen] };
        });
    }
    deleteComments() {
        this._pruneComments();
        return Object.keys(this._comments).map((fen) => {
            const comment = this._comments[fen];
            delete this._comments[fen];
            return { fen: fen, comment: comment };
        });
    }
}

function chessSquareToText(square) {
    return ["a", "b", "c", "d", "e", "f", "g", "h"][square.file] + (8 - square.row);
}

class ChessBoard extends React.Component {
    constructor(props) {
        super(props);
        this._chess = new Chess();
        this.promotionMenu = React.createRef();
        this.state = {
            pieces: Array(8).fill([])
        };
        this.onClick = this.onClick.bind(this);
        this.onMove = this.onMove.bind(this);
    }
    render() {
        return (jsxs("div", Object.assign({ style: {
                width: '100%',
                aspectRatio: '1/1',
            }, onClick: this.onClick }, { children: [jsx(ChessBoardSquares, { pieces: this.state.pieces, onMove: this.onMove }), jsx(ChessBoardPromotionMenu, { ref: this.promotionMenu })] })));
    }
    onClick() {
    }
    updatePieces() {
        this.setState({
            pieces: this._chess.board().map(row => {
                return row.map(piece => {
                    if (piece == null)
                        return undefined;
                    return {
                        color: piece.color == "w" ? ChessColor.WHITE : ChessColor.BLACK,
                        type: ["p", "n", "b", "r", "q", "k"].indexOf(piece.type)
                    };
                });
            })
        });
    }
    componentDidMount() {
        this.updatePieces();
    }
    onMove(move) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            var promotionTo = undefined;
            if (((_a = this.state.pieces[move.from.row][move.from.file]) === null || _a === void 0 ? void 0 : _a.type) == ChessPieceType.PAWN) {
                if (((_b = this.state.pieces[move.from.row][move.from.file]) === null || _b === void 0 ? void 0 : _b.color) == ChessColor.WHITE && move.to.row == 0) {
                    // White pawn promotion
                    if (this.promotionMenu.current) {
                        promotionTo = yield this.promotionMenu.current.openAsync(ChessColor.WHITE, move.to.file);
                        if (!promotionTo)
                            return;
                    }
                }
                if (((_c = this.state.pieces[move.from.row][move.from.file]) === null || _c === void 0 ? void 0 : _c.color) == ChessColor.BLACK && move.to.row == 7) {
                    // Black pawn promotion
                    if (this.promotionMenu.current) {
                        promotionTo = yield this.promotionMenu.current.openAsync(ChessColor.BLACK, move.to.file);
                        if (!promotionTo)
                            return;
                    }
                }
            }
            try {
                this._chess.move({
                    from: chessSquareToText(move.from),
                    to: chessSquareToText(move.to),
                    promotion: typeof promotionTo == 'number' ? ["p", "k", "b", "r", "q", "k"][promotionTo] : undefined
                });
            }
            catch (e) {
                // Invalid move, just ignore it
                return;
            }
            this.updatePieces();
        });
    }
}

export { ChessBoard };
